<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[TIP - CG.Lee Blog]]></title><description><![CDATA[Thoughts, stories and ideas.]]></description><link>https://blog.chulgil.me/</link><image><url>https://blog.chulgil.me/favicon.png</url><title>TIP - CG.Lee Blog</title><link>https://blog.chulgil.me/</link></image><generator>Ghost 2.10</generator><lastBuildDate>Mon, 11 Feb 2019 19:29:10 GMT</lastBuildDate><atom:link href="https://blog.chulgil.me/tag/tip/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[토큰기반 인증 파헤치기(AngularJS & Node.js )]]></title><description><![CDATA[<hr>
<h3 id="">토큰 기반 인증 시스템을 설명하기 전에, 먼저 전통적인 인증 시스템을 살펴보자.</h3>
<p><img src="https://blog.chulgil.me/content/images/2019/02/token.png" alt="token"></p>
<ol>
<li>사용자는 username과 password를 로그인 폼에 입력하고 Login 버튼을 클릭한다.</li>
<li>서버는 요청이 들어오면 DB를 쿼리하여 user를 검증한다. 만약 요청이 유효하면 세션을 생성하고 세션 정보를 Response 헤더에 포함시켜 반환한다.</li>
<li>클라이언트는 제한된 end points에 접근할 때 모든 Request Header에 세션 정보를 포함시킨다.</li></ol>]]></description><link>https://blog.chulgil.me/token-based-authentication-with-angularjs/</link><guid isPermaLink="false">5c58c3e38db38e000104533e</guid><category><![CDATA[kr]]></category><category><![CDATA[CODE]]></category><category><![CDATA[TIP]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Tue, 05 Feb 2019 10:00:00 GMT</pubDate><content:encoded><![CDATA[<hr>
<h3 id="">토큰 기반 인증 시스템을 설명하기 전에, 먼저 전통적인 인증 시스템을 살펴보자.</h3>
<p><img src="https://blog.chulgil.me/content/images/2019/02/token.png" alt="token"></p>
<ol>
<li>사용자는 username과 password를 로그인 폼에 입력하고 Login 버튼을 클릭한다.</li>
<li>서버는 요청이 들어오면 DB를 쿼리하여 user를 검증한다. 만약 요청이 유효하면 세션을 생성하고 세션 정보를 Response 헤더에 포함시켜 반환한다.</li>
<li>클라이언트는 제한된 end points에 접근할 때 모든 Request Header에 세션 정보를 포함시킨다.</li>
<li>만약 세션 정보가 유효하면 서버는 사용자가 특정 end point에 접근하는 것을 허용하고 렌더링된 HTML 내용을 반환한다.</li>
</ol>
<p>여기까지는 문제가 없다. 웹 어플리케이션은 잘 동작하고, 사용자 인증을 거쳐서 특정 endpoint로의 접근을 제한할 수 있다. 하지만 안드로이드와 같은 다른 클라이언트에서 동작하는 어플리케이션을 만들고 싶다면 어떨까? 전통적인 인증 방식으로 동작하는 어플리케이션을 모바일 클라이언트에서도 동일하게 사용할 수 있을까? 그렇지 않다. 그 이유는 다음과 같다.</p>
<ol>
<li>세션과 쿠키는 모바일 어플리케이션에서 make sense하지 않다. 서버에서 생성된 세션과 쿠키를 모바일 클라이언트에서는 공유할 수 없다.</li>
<li>현재 어플리케이션에서 렌더링된 HTML이 반환되었다. 모바일 클라이언트에서는 JSON 또는 XML와 같은 포맷의 응답이 필요하다.<br>
이러한 경우 클라이언트 독립적인 어플리케이션 이 필요하다.</li>
</ol>
<p>So, what is this JWT?</p>
<hr>
<h3 id="jwt">JWT</h3>
<p>JWT는 JSON Web Token의 약자이며 인증 헤더 내에서 사용되는 토큰 포맷이다. 이 토큰은 두 개의 시스템끼리 안전한 방법으로 통신할 수 있도록 설계하는 것을 도와준다. 이 튜토리얼에서는 JWT를 &quot;Bearer 토큰&quot;으로 부르도록 하겠다. Bearer 토큰은 3가지 요소로 구성된다 : Header, Payload, Signature.</p>
<p>Header는 토큰 타입과 암호화 방법을 보관하는 토큰의 한 부분이며, Base-64로 인코딩된다.<br>
Payload에는 유저 정보, 상품 정보 등의 다양한 종류의 정보를 넣을 수 있다. Base-64로 인코딩된다.<br>
Signature는 Header, Payload, Secret key의 조합이다. Secret key는 반드시 서버에 안전하게 보관되어야 한다.</p>
<p>JTW의 장점은 계정 서버와 API 서버가 분리되어 있을 때, API 서버가 계정 서버에게 토큰의 유효성 여부를 물어보지 않고도 스스로 판단할 수 있다는 것이다.</p>
<p>JWT 스키마와 토큰 예제는 아래와 같다.</p>
<p><img src="https://blog.chulgil.me/content/images/2019/02/token2.png" alt="token2"></p>
<p>몇가지 언어에서 이미 구현되어 있기 때문에 Bearer 토큰을 생성하는 코드를 직접 구현할 필요는 없다.</p>
<pre><code>###### Language Livbary URL 

 - NodeJS : http://github.com/auth0/node-jsonwebtoken  
 - PHP : http://github.com/firebase/php-jwt  
 - Java : http://github.com/auth0/java-jwt  
 - Ruby : http://github.com/progrium/ruby-jwt  
 - .NET : http://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet  
 - Python : http://github.com/progrium/pyjwt/  

</code></pre>
<hr>
<h3 id="">예제 살펴보기</h3>
<p>토큰 기반 인증에 대해 몇가지 기본 정보를 다뤘기 때문에 이제 연습 예제를 진행해보자. 아래 스키마를 잘 봐두길 바란다.</p>
<p><img src="https://blog.chulgil.me/content/images/2019/02/token3.png" alt="token3"></p>
<ol>
<li>API에 대한 요청은 여러 클라이언트에 의해 생성된다. (웹 어플리케이션, 모바일 클라이언트, ...)</li>
<li>요청은 <a href="https://api.yourexampleapp.xn--com-rg8l">https://api.yourexampleapp.com과</a> 같은 서비스에게 전달된다. 많은 사람들이 어플리케이션을 사용하면 요청을 수행하기 위해 여러개의 서버가 필요할 것이다.</li>
<li>여기서 가장 적합한 서버로 요청하기 위해 로드 밸런서가 사용된다. <a href="https://api.yourexamplapp.xn--com-ky7m580d">https://api.yourexamplapp.com으로</a> 요청 발생하면 먼저 로드 밸런서가 요청을 제어하고 특정 서버로 클라이언트를 redirect 시킨다.</li>
<li>하나의 어플리케이션이 있고 이 어플리케이션은 여러 서버로 배치된다 (server-1, server-2, ..., server-n). 요청이 만들어질 때마다 백엔드 어플리케이션은 요청 헤더를 가로채서 인증 헤더 내의 토큰 정보를 추출해낸다. DB 쿼리는 이 토큰을 사용하여 만들어질 것이다. 만약 토큰이 유효하고 end point에 접근하기 위해 요구되는 권한을 갖고 있다면 문제없이 진행될 것이다. 만약 그렇지 않다면 403 응답 코드(forbidden status)를 반환할 것이다.</li>
</ol>
<hr>
<h3 id="">토큰기반 인증의 장점</h3>
<p>토큰 기반 인증은 심각한 문제들을 해결해주는 몇가지 이점을 갖는다. 그 중 일부는 아래와 같다.</p>
<ul>
<li>
<p>클라이언트 독립적인 서비스. 토큰 기반 인증에서 토큰은 요청 헤더를 통해 전달된다. 이것은 stateless를 의미한다. HTTP 요청을 만들 수 있는 클라이언트라면 누구든지 서버로 요청을 보낼 수 있다.</p>
</li>
<li>
<p>CDN. 대부분의 현재 웹 어플리케이션 내에서 view는 백엔드 상에서 렌더링되고 브라우저로 HTML이 반환된다. 프론트엔드의 로직이 백엔드 코드와 의존성이 있는 것이다. 이렇게 의존성이 생기면 몇가지 문제가 발생한다. 예를 들어, 프론트엔드 HTML, CSS, JS 등을 구현하는 디자인 에이전시와 함께 일을 한다고 가정해보자. 우리는 일부 렌더링 또는 생성 동작을 수행하기 위해 프론트엔드 코드를 가져와서 백엔드 코드에 통합시켜야 한다. 어쩌면 렌더링된 HTML 컨텐츠는 디자인 에이전시가 구현했던 것과 아주 많이 다를 것이다. 토큰 기반 인증에서는 프론트엔드 프로젝트를 백엔드로부터 독립적으로 개발하도록 할 수 있다. 백엔드 코드는 렌더링된 HTML 대신 JSON 응답을 반환할 것이고, 경량화되고 압축된 버전의 프론트엔드 코드는 CDN에 넣어둘 수가 있다. 누군가 웹페이지에 방문하면 HTML 컨텐츠는 CDN에서 제공되고 페이지의 내용은 인증 헤더의 토큰을 사용하는 API 서비스에 의해 생성될 것이다.</p>
</li>
<li>
<p>No Cookie-Session (or NO CSRF). CSRF(사이트간 요청 위조)는 세션 유지에 일반적으로 사용되는 쿠키 정보만 만족하면 요청이 수행되는 취약점을 이용한 공격이다. 예를 들어, 이미 사이트에 로그인하여 쿠키를 들고 있는 사용자가 공격자가 유도한 링크(회원 탈퇴 링크)에 노출되면 회원 탈퇴 요청이 서버로 전달되고 탈퇴가 되어버린다. 이미 쿠키가 사용자 정보를 포함하고 있기 때문에 회원 탈퇴 요청 URL로 접속만하면 웹서버는 요청을 신뢰하고 명령을 수행하는 것이다. 이 문제를 해결하기 위해 탈퇴 시 비밀번호를 한번 더 요구하거나 요청에 토큰과 같은 credential을 포함하는 방법을 사용한다. 토큰 기반 인증에서 토큰은 인증 헤더 내에 포함되기 때문에 CSRF를 방지할 수 있다.</p>
</li>
<li>
<p>지속적인 토큰 저장. 어플리케이션 내에서 세션 읽기, 쓰기, 삭제 동작이 발생하면 최소 1회 OS의 temp 폴더에 file 관련 동작이 발생한다. 여러개의 서버를 갖고 있고 한 세션이 첫번째 서버에 생성되었다고 해보자. 이 상태에서 새로운 요청이 발생하고 그 요청이 다른 서버에 전달되면, 해당 서버에는 세션 정보가 없을 것이기 때문에 &quot;unauthrized&quot; 응답을 받을 것이다. 물론 sticky 세션(처음에 접속했던 서버와 같은 서버에 계속 연결시키는 것)을 사용하여 이 문제를 해결할 수 있다. 하지만 토큰 기반 인증에서는 이 문제 자연스럽게 해결된다. 요청 토큰은 모든 요청, 모든 서버가 가로채기 때문이다.</p>
</li>
</ul>
<p>이것들이 토큰 기반 인증의 가장 일반적인 장점이다. 이로써 이론적인 설명을 마치고 연습 예제를 보도록 하자.</p>
<hr>
<h3 id="2">토큰기반 인증을 시연하기위해 아래 2개의 어플리케이션 을 살펴보자.</h3>
<ol>
<li>token-based-auth-backend</li>
<li>token-based-auth-frontend</li>
</ol>
<p>백엔드 프로젝트 예제에서는 서비스가 실행되고 서비스의 결과가 JSON 포맷으로 반환될 것이다. 서비스에서는 결코 view가 리턴되지 않는다. 프론트엔드 예제는 HTML을 위한 AngularJS 프로젝트이며, 프론트엔드 앱은 백엔드 서비스로 요청을 보내는 AngularJS 서비스에 의해 작성될 것이다.</p>
<h4 id="tokenbasedauthbackend">token-based-auth-backend</h4>
<pre><code>// mongoose를 사용하기 위해 해당 모듈을 import
var mongoose    = require('mongoose'); 

// 스키마 정의

./models/Users.js
// email, password, token 필드를 가지며 각각의 필드는 string 타입이다.
var Schema       = mongoose.Schema;
var UserSchema   = new Schema({
    email: String,
    password: String,
    token: String
});

// 스키마를 이용해서 모델을 정의
// 'User' : mongodb에 저장될 collection이름(테이블명)
// UserSchema : 모델을 정의하는데 사용할 스키마
module.exports = mongoose.model('User', UserSchema);
</code></pre>
<p>./server.js</p>
<pre><code>// 필요한 모듈 import
var express    = require(&quot;express&quot;);
var morgan       = require(&quot;morgan&quot;);
var bodyParser = require(&quot;body-parser&quot;);
var jwt             = require(&quot;jsonwebtoken&quot;);
var mongoose  = require(&quot;mongoose&quot;);
var app           = express();

var port = process.env.PORT || 3001;
var User     = require('./models/User');

// DB 연결
mongoose.connect(process.env.MONGO_URL); //mongodb://localhost/dbname

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());
app.use(morgan(&quot;dev&quot;)); // 모든 요청을 console에 기록
app.use(methodOverride()); // DELETE, PUT method 사용
app.use(function(req, res, next) {
    //모든 도메인의 요청을 허용하지 않으면 웹브라우저에서 CORS 에러를 발생시킨다.
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,content-type, Authorization');
    next();
});


// 로그인
// 다른 endpoint에 접근할 수 있는 토큰을 얻는다.
app.post('/authenticate', function(req, res) {
    User.findOne({email: req.body.email, password: req.body.password}, function(err, user) {
        if (err) {
            res.json({
                type: false,
                data: &quot;Error occured: &quot; + err
            });
        } else {
            if (user) {
               res.json({
                    type: true,
                    data: user,
                    token: user.token
                }); 
            } else {
                res.json({
                    type: false,
                    data: &quot;Incorrect email/password&quot;
                });    
            }
        }
    });
});

// 신규가입
// 계정과 토큰을 생성한다.
app.post('/signin', function(req, res) {
    User.findOne({email: req.body.email, password: req.body.password}, function(err, user) {
        if (err) {
            res.json({
                type: false,
                data: &quot;Error occured: &quot; + err
            });
        } else {
            if (user) {
                res.json({
                    type: false,
                    data: &quot;User already exists!&quot;
                });
            } else {
                var userModel = new User();
                userModel.email = req.body.email;
                userModel.password = req.body.password;
                userModel.save(function(err, user) { // DB 저장 완료되면 콜백 함수 호출
                    user.token = jwt.sign(user, process.env.JWT_SECRET); // user 정보로부터 토큰 생성
                    user.save(function(err, user1) {
                        res.json({
                            type: true,
                            data: user1,
                            token: user1.token
                        });
                    });
                })
            }
        }
    });
});

// 나의 정보
// 토큰 검사 후 계정 정보 반환
// 토큰 추출하기 위해 ensureAuthorized 먼저 실행
app.get('/me', ensureAuthorized, function(req, res) {
    User.findOne({token: req.token}, function(err, user) {
        if (err) {
            res.json({
                type: false,
                data: &quot;Error occured: &quot; + err
            });
        } else {
            res.json({
                type: true,
                data: user
            });
        }
    });
});

// 요청 헤더 내의 authorization 헤더에서 토큰 추출
// 토큰이 존재하면, 토큰을 req.token에 할당
function ensureAuthorized(req, res, next) {
    var bearerToken;
    var bearerHeader = req.headers[&quot;authorization&quot;];
    if (typeof bearerHeader !== 'undefined') {
        var bearer = bearerHeader.split(&quot; &quot;);
        bearerToken = bearer[1];
        req.token = bearerToken;
        next(); // 다음 콜백함수 진행
    } else {
        res.send(403);
    }
}

process.on('uncaughtException', function(err) {
    console.log(err);
});

// Start Server
app.listen(port, function () {
    console.log( &quot;Express server listening on port &quot; + port);
});
</code></pre>
<h3 id="">결론</h3>
<p>클라이언트 독립적인 서비스를 구현할 때 토큰 기반 인증/인가 방식은 인증 시스템을 구축하는데 많은 도움을 준다. 이 기술을 사용함으로써 서비스(또는 API) 개발에만 집중할 수 있다. 인증/인가 부분은 토큰 기반 인증 시스템에 의해 서비스의 앞단에서 하나의 '레이어'로써 핸들링될 것이다. 웹 브라우저, 안드로이드, iOS, 데스크탑 클라이언트 등 어떤 클라이언트를 통해서도 서비스에 접근하고 서비스를 사용할 수 있다.</p>
<p>이 링크에서 튜토리얼을 확인할 수 있다.<br>
<a href="http://token-based-auth.herokuapp.com/">working demo</a>.</p>
<h3 id="">개선사항</h3>
<ol>
<li>비밀번호가 해쉬 암호화되어 저장되어야하고 로그인시 해쉬값을 전달받아 비교해야 한다.</li>
</ol>
<pre><code>// bcrypt 사용
UserScheme.pre('save', function (callback) { 
  // salt와 암호화된 비밀번호 생성
  var user = this;
  if (!user.isModified('password')) return next();
 
  bcrypt.genSalt(SALT_WORK_FACTOR, function(err, salt) {
    if (err) return next(err);
 
    bcrypt.hash(user.password, salt, function(err, hash) {
        if (err) return next(err);
        user.password = hash;
        next();
    });
  });
}

// 비밀번호 검증
UserSchema.methods.verifyPassword = function(password, cb) {    
    bcrypt.compare(password, this.password, function(err, isMatch) {
        if (err) return cb(err);
        cb(isMatch);
    });
};

// 로그인
app.post('/authenticate', function(req, res) {
...
      user.comparePassword(password, function(isMatch) {
          if (!isMatch) {
              console.log(&quot;Attempt failed to login with &quot; + user.username);
              return res.send(401);
          }
          ...
      });
...
}
</code></pre>
<ol start="2">
<li>토큰의 유효성 검사가 수행되어야 하며, 토큰이 만료되어야 한다.</li>
</ol>
<pre><code>function ensureAuthorized(req, res, next) {
    ...
    jwt.verify(bearerToken, process.env.JWT_SECRET)
    ...
}
</code></pre>
<p>위의 개선사항이 반영된 소스 :</p>
<ul>
<li><a href="http://thejackalofjavascript.com/architecting-a-restful-node-js-app/">http://thejackalofjavascript.com/architecting-a-restful-node-js-app/</a></li>
<li><a href="http://www.kdelemme.com/2014/03/09/authentication-with-angularjs-and-a-node-js-rest-api/">http://www.kdelemme.com/2014/03/09/authentication-with-angularjs-and-a-node-js-rest-api/</a></li>
</ul>
<p>참고자료 :</p>
<ol>
<li><a href="http://bcho.tistory.com/999">REST JWT(JSON Web Token)소개</a></li>
<li><a href="http://bcho.tistory.com/1005">MSA 아키텍쳐 구현을 위한 API 게이트웨이의 이해 (API GATEWAY)</a></li>
<li><a href="https://velopert.com/2350">토큰기반인증소개</a></li>
<li><a href="https://www.toptal.com/web/cookie-free-authentication-with-json-web-tokens-an-example-in-laravel-and-angularjs">Laravel&amp;Angularjs Login</a></li>
</ol>
]]></content:encoded></item><item><title><![CDATA[온라인으로 교통위반 티켓요금 납부하기 - 일리노이주]]></title><description><![CDATA[<p>2019년 2월 첫째주 시카고는 극심한 추위로 영하 30도까지 내려갔다.<br>
덕분에 야외 주차장에 세워놓은 내 차가 배터리가 불량이 되었는데 차를 끌고 회사에 가기 전까지는 몰랐다.<br>
회사근처에서 신호대기를 하며 브레이크를 밟고 있었는데 갑자기 에러메시지가 뜨면서 차가 서버렸다.<br>
당황한 나는 바로 보험회사에 전화하고 있었는데 경찰이 와서 바로 견인차를 불러주었다.<br>
그 과정에서 내 라이센스</p>]]></description><link>https://blog.chulgil.me/how-to-pay-online-for-ticket/</link><guid isPermaLink="false">5c58986f8db38e000104530c</guid><category><![CDATA[kr]]></category><category><![CDATA[TIP]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Mon, 04 Feb 2019 20:22:05 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1465487438571-59340bfc35dd?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1465487438571-59340bfc35dd?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ" alt="온라인으로 교통위반 티켓요금 납부하기 - 일리노이주"><p>2019년 2월 첫째주 시카고는 극심한 추위로 영하 30도까지 내려갔다.<br>
덕분에 야외 주차장에 세워놓은 내 차가 배터리가 불량이 되었는데 차를 끌고 회사에 가기 전까지는 몰랐다.<br>
회사근처에서 신호대기를 하며 브레이크를 밟고 있었는데 갑자기 에러메시지가 뜨면서 차가 서버렸다.<br>
당황한 나는 바로 보험회사에 전화하고 있었는데 경찰이 와서 바로 견인차를 불러주었다.<br>
그 과정에서 내 라이센스 플레이트가 시카고가 아닌 캘리포니아꺼라 바로 티켓을 끊어줬다.</p>
<p>미국은 다른주로 이사가게 되면 바로 플레이트와 운전면허증을 해당 주로 변경해야한다.<br>
나의 경우 운전면허증은 갱신했으나 플레이트는 다른DMV가서 신청하라고해서 대기하던 도중에 딱 딱지를 받게 되었다. 다행이도 35불 나왔다.</p>
<p><img src="https://blog.chulgil.me/content/images/2019/02/Screen-Shot-2019-02-04-at-2.10.36-PM-1.png" alt="온라인으로 교통위반 티켓요금 납부하기 - 일리노이주"><br>
<img src="https://blog.chulgil.me/content/images/2019/02/Screen-Shot-2019-02-04-at-2.10.57-PM.png" alt="온라인으로 교통위반 티켓요금 납부하기 - 일리노이주"></p>
<p>어찌되었건 벌금은 바로 납부해야해서 온라인으로 하는 방법이 있는지 알아보다가 나처럼 헤매는 분들에게 조금이라도 도움이 될수 있다면 해서 이 글을 작성하게 되었다.</p>
<p>주마다 벌금을 내는 곳은 다르다. 일리노이의 경우는 아래 링크에서 온라인으로 페이가 가능하다.</p>
<p><a href="http://www.villageofschillerpark.com">http://www.villageofschillerpark.com</a></p>
<ol>
<li>처음 페이지에서 중간쯤 보면 Online Payment 를 클릭힌다.</li>
<li>Online Payments에서 Parking Tickets를 클릭하면 <a href="https://ww2.tmainc.us/XSaLTWebs/payAnything?Client=SHL">다른 링크</a>로 이동하게 되는데 여기서 페이가 가능하다.<br>
<img src="https://blog.chulgil.me/content/images/2019/02/Screen-Shot-2019-02-04-at-2.15.43-PM.png" alt="온라인으로 교통위반 티켓요금 납부하기 - 일리노이주"></li>
<li>티켓번호와 벌금을 입력하고 본인의 카드번호를 입력하면 바로 결재가 완료된다.</li>
</ol>
<p>나처럼 타 주로 이사하시는 분들은 빠른시일내에 바로 DMV에가서 운전면허와 라이센스를 꼭 변경하길 바란다.</p>
]]></content:encoded></item><item><title><![CDATA[블로그 만들기 GitHub 심화 5편 - GitBook만들기]]></title><description><![CDATA[<h1 id="">목차</h1>
<ul>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github/">블로그 만들기 GitHub 총정리</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-1/">블로그 만들기 GitHub 기본 1편 - 사용자 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-2/">블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-3/">블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-4/">블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</a></li>
<li><strong>블로그 만들기 GitHub 심화 5편 - GitBook만들기</strong></li>
</ul>
<hr><h1 id="gitbook">GitBook 소개</h1>
<p>블로그를 운영하다보면 지금 보는</p>]]></description><link>https://blog.chulgil.me/how-to-make-blog-using-github-5/</link><guid isPermaLink="false">5c4767358db38e0001044e6f</guid><category><![CDATA[kr]]></category><category><![CDATA[BLOG]]></category><category><![CDATA[TIP]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Tue, 22 Jan 2019 21:22:52 GMT</pubDate><content:encoded><![CDATA[<h1 id="">목차</h1>
<ul>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github/">블로그 만들기 GitHub 총정리</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-1/">블로그 만들기 GitHub 기본 1편 - 사용자 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-2/">블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-3/">블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-4/">블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</a></li>
<li><strong>블로그 만들기 GitHub 심화 5편 - GitBook만들기</strong></li>
</ul>
<hr><h1 id="gitbook">GitBook 소개</h1>
<p>블로그를 운영하다보면 지금 보는 포스트와 같이 시리즈로 연재하는 경우 책과 같이 만들고 싶은 경우가 있다. 그리고 회사에서 어떤 서비스를 운영할때 메뉴얼을 배포하고자 할때도 GitBook을 사용하면 편리하다.<br>
GitBook으로 만들어진 컨텐츠는 e북 형식(PDF, ePub, Mobi)로 만들 수 있기 때문에 활용도가 높다.</p>
<p>GitBook을 만드는 방법은 기본적으로 아래 두가지가 있다.</p>
<ol>
<li>온라인 : <a href="https://www.gitbook.com">https://www.gitbook.com</a></li>
<li>오프라인 : 내컴퓨터에 설치</li>
</ol>
<p>온라인버젼의 경우 이전에는 <a href="https://legacy.gitbook.com">https://legacy.gitbook.com</a> 에서 서비스 하고있었는데 현재는 new버젼으로 legacy가 제외된 url로 통합되었다.<br>
그리고 무료버젼의 경우 하나의 프로젝트만 공개할 수 있어서 테스트삼아 서비스하는 것외엔 의미가 없는 것같다.</p>
<p><img src="https://blog.chulgil.me/content/images/2019/01/blog9-1-1.jpg" alt="blog9-1-1"></p>
<h2 id="macgitbookgithub">이 글에서는 직접 Mac에 설치해서 GitBook제작후 GitHub에 올려서 서비스하는 과정을 공유한다.</h2>
<hr><h2 id="gitbook">GitBook 설치하기</h2>
<p>커맨드라인에서 아래 명령어로 설치한후 <a href="http://localhost:4000">localhost:4000</a> 으로 접속해보면 기본적인 GitBook을 확인할 수 있다.</p>
<pre><code>$ npm install gitbook-cli -g
$ gitbook init ./tutorial
$ gitbook serve
</code></pre>
<p>아래 명령어로 디버깅도 가능하다.</p>
<pre><code>$ gitbook build ./ --log=debug --debug
</code></pre>
<p>생성된 기본적인 디렉토리 구조는 아래와 같다.</p>
<pre><code>.
├── book.json            # 기본 GitBook구성 데이터(선택)
├── README.md            # 서적 소개(필수)
├── SUMMARY.md           # 목차 참조(선택)
├── GLOSSARY.md          # 용어 정리(선택 : 직접파일 성생필요) 
├── chapter-1/
|   ├── README.md
|   └── something.md
└── chapter-2/
    ├── README.md
    └── something.md
</code></pre>
<hr><h2 id="">목차 만들기</h2>
<p>GitBook은 SUMMARY.md 파일을 사용하여 메인챕터와 서브챕터의 구조를 정의한다.<br>
이 SUMMARY.md파일은 책의 목차를 생성하는 데 사용된다.<br>
이 파일의 형식은 간단한 링크들로만 구성되어있다.<br>
링크의 제목은 챕터의 제목으로 사용되며 링크의 대상은 해당 챕터의 파일 경로이다.<br>
앵커로도 사용가능한데 아래 예를 보면 파트II에서 (part#/README.md)링크가 들어 있는 것을 볼 수 있다.</p>
<p>간단한 예</p>
<pre><code># 목차

* [읽어보기](README.md)

### 파트 I

* [GitBook의 글쓰기](part1/writing.md)
* [GitBook의 설명](part1/gitbook.md)
    
### 파트 II 앵커로 사용하기 (part2/README.md) 

* [피드백주세요](part2/README.md#feedback)
* [더좋은 툴들](part2/README.md#tools)

----

</code></pre>
<h2 id="">페이지 작성하기</h2>
<p>서브폴더를 만들고 목차에서 작성한 파일명으로 생성하면 페이지가 연동된다.<br>
기본적으로 GitBook도 마크다운 형식으로 작성해야 하기때문에 심플하다.</p>
<pre><code>$ mkdir part1
$ touch writing.md
</code></pre>
<p>writing.md에 아래 내용을 복붙하고 서버를 실행시키면 목차와 페이지가 생성된 것을 확인할 수 있다.</p>
<pre><code>---
description: 페이지의 간략설명입니다.
---

# 챕터의 제목

소개글 입니다.

## 섹션 1

마크다운은 당신의 책을 가장 잘 표현할수 있습니다.  **book's structure**

## 섹션 2

</code></pre>
<h3 id="github">GitHub에 배포하기</h3>
<p>이제  GitHub웹 사이트로 배포 해보자. 이전 과는 다르게 마스터 브랜치가 아닌 <code>gh-pages</code>브랜치 에 파일을 추가해야 한다. gitbook 명령어로는 이런 과정을 지원하지 않기때문에 메뉴얼로 해야한다.<br>
먼저 GitHub에서 새로운 저장소의 이름을 gitbook(다른이름으로 만들어도된다.)으로 만든다음 로컬로 가져온다.</p>
<pre><code>$ git clone git@github.com:username/gitbook.git
$ cd gitbook
$ git checkout -b gh-pages
$ cp -R ../tutorial/_book/* .
$ git clean -fx node_modules
$ git clean -fx _book
</code></pre>
<p>이제 Git으로 Push하고 나면 별도 설정없이 <a href="https://username.github.io/gitbook/">https://username.github.io/gitbook/</a> 에 배포가 된것을 확인 할 수 있다.</p>
<pre><code>$ git add .
$ git commit -a -m &quot;init gitbook&quot;
$ git push origin gh-pages
$ git checkout master
</code></pre>
<p><img src="https://blog.chulgil.me/content/images/2019/01/blog9-2.jpg" alt="blog9-2"></p>
<p></p>]]></content:encoded></item><item><title><![CDATA[블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿]]></title><description><![CDATA[<h1 id="">목차</h1>
<ul>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github/">블로그 만들기 GitHub 총정리</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-1/">블로그 만들기 GitHub 기본 1편 - 사용자 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-2/">블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-3/">블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</a></li>
<li><strong>블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</strong></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-5/">블로그 만들기 GitHub 심화 5편 - GitBook만들기</a></li>
</ul>
<hr><p>지난번 글에서는 기본제공되는 심플한 블로그 위주로</p>]]></description><link>https://blog.chulgil.me/how-to-make-blog-using-github-4/</link><guid isPermaLink="false">5c44f3aa8db38e0001044d89</guid><category><![CDATA[kr]]></category><category><![CDATA[BLOG]]></category><category><![CDATA[TIP]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Sun, 20 Jan 2019 22:22:00 GMT</pubDate><content:encoded><![CDATA[<h1 id="">목차</h1>
<ul>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github/">블로그 만들기 GitHub 총정리</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-1/">블로그 만들기 GitHub 기본 1편 - 사용자 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-2/">블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-3/">블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</a></li>
<li><strong>블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</strong></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-5/">블로그 만들기 GitHub 심화 5편 - GitBook만들기</a></li>
</ul>
<hr><p>지난번 글에서는 기본제공되는 심플한 블로그 위주로 구성했었기 때문에 맘에드는 테마가 없어 실망했을수 있다.  하지만 이번 글에서는 설치할 수 있는 무료 테마를 알아보고 테마를 설치하는 법을 공유한다.</p>
<h2 id="">이번 글에서는 아래와 같은 목차로 블로그만드는 방법을 설명한다.</h2>
<blockquote>
<ol>
<li>로컬환경에서 테마를 설치</li>
<li>테마 수정</li>
<li>GitHub로 배포</li>
</ol>
</blockquote>
<p>기본적으로 <a href="https://jekyllthemes.io">https://jekyllthemes.io</a> 에 접속하면 유료 및 무료 테마를 다운받을 수 있다.<br>
나는 그중에서 Mediumish가 맘에들어 이 테마로 설치하려 한다.<br>
먼저 완성된 블로그의 모습을 확인하자.</p>
<h2 id="1">1. 로컬에서 테마를 설치</h2>
<p>터미널에서 아래 url로 테마를 클론한다.</p>
<pre><code>$ git clone https://github.com/wowthemesnet/mediumish-theme-jekyll.git
$ cd mediumish-theme-jekyll
$ bundle
$ jekyll serve
</code></pre>
<p>여기까지 진행하였다면  <code>localhost:4000</code>로 접속해보자.<br>
블로그가 완성되어있는 것을 확인 할 수 있다.</p>
<h2 id="2">2. 테마 수정</h2>
<p>완성된 블로그에 내가 쓴글이 아닌 포스트와 메뉴들을 삭제하고 본격적으로 나의 사이트로 바꿔보자.<br>
일단 <code>_config.yml</code> 파일을 열어보면 메인 사이트 정보가 있는데 이것을 수정하자.</p>
<h3 id="">사이트 기본설정</h3>
<pre><code># Site
name: '블로그 제목'
description: '블로그 설명'
meta_description: '블로그 메타테그'
logo: 'assets/images/logo.png'
favicon: 'assets/images/logo.png'
baseurl: '/저장소이름/'
google_analytics: ''
disqus: '' #댓글 api 이용시 disqus-id 입력
mailchimp-list: ''
</code></pre>
<h3 id="">사이트 운영자 설정</h3>
<pre><code># Authors
authors:
  sal:
    name: 사용자 이름
    display_name: 표시될 이름
    gravatar: 
    email: email@gmail.com
    web: https://username.github.io
    twitter: https://twitter.com/username
    description: &quot;사용자 설명&quot;
</code></pre>
<h3 id="">첫 포스트 작성하기</h3>
<p>먼저 작성되어있는 불필요한 파일들을 삭제한다.<br>
커맨드라인을 통해서 삭제해도 되고 탐색기나 에디터로 삭제 해도된다.</p>
<pre><code>$ rm -fr .git
$ rm README.md
$ rm LICENSE.txt
$ rm -fr _posts/*
</code></pre>
<p>_posts/폴더에 custom_file.md 파일을 생성하고 아래 내용을 넣으면 포스팅이 완료된다.</p>
<pre><code>---
layout: post
title:  &quot;첫포스트&quot;
author: 사용자명
categories: [ Jekyll ]
image: assets/images/11.jpg
featured: true
hidden: false
---

## 첫 블로그 포스트 입니다.

지킬은 심플한 정적 사이트 생성기 입니다.
지킬은 심플한 정적 사이트 생성기 입니다.
지킬은 심플한 정적 사이트 생성기 입니다.
지킬은 심플한 정적 사이트 생성기 입니다.
지킬은 심플한 정적 사이트 생성기 입니다.
지킬은 심플한 정적 사이트 생성기 입니다.
지킬은 심플한 정적 사이트 생성기 입니다.
지킬은 심플한 정적 사이트 생성기 입니다.
</code></pre>
<h3 id="">메뉴 수정하기</h3>
<p><code>_layout/default.html</code> 파일에 메뉴정보가 있다.</p>
<p>아래 li a 태그를 만들고자하는 메뉴로 수정하면된다.</p>
<pre><code>&lt;!-- Begin Menu --&gt;
  &lt;ul class=&quot;navbar-nav ml-auto&quot;&gt;
                
    &lt;li class=&quot;nav-item&quot;&gt;
      &lt;a class=&quot;nav-link&quot; href=&quot;{{ site.baseurl }}/&quot;&gt;Blog&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;!-- End Menu --&gt;            
</code></pre>
<p>이제 다시 테스트서버를 띄워보면 정보가 변경된것을 확인 할 수 있다.</p>
<pre><code>$ jekyll serve
</code></pre>
<h2 id="3github">3. GitHub로 배포</h2>
<blockquote>
<p>그전에 많은 사람들이 <code>_config.yml</code>  baseurl의 모호한 설명으로 많은 문제를 겪고있다.<br>
나처럼 프로젝트단위로 url을 구성한경우  baseurl뒤에 '/'이 있는지 꼭 확인하자</p>
</blockquote>
<pre><code>baseurl: '/저장소이름/'
</code></pre>
<p>이제 웹에서 블로그를 확인할 수 있게 본인의 GitHub에서 저장소를 추가한후 위에 만들어놓은<br>
파일들을 추가하고 push하자.</p>
<pre><code>$ git clone git@github.com:username/jekyll-mediumish.git
$ cd jekyll-mediumish
$ mv ../mediumish-theme-jekyll/* ./
$ git add .
$ git commit -m 'init jekyll theme'
$ git push
</code></pre>
<p>이제 이전 포스트에서 설명했듯 GitHub Pages &gt; Source &gt; master branch 로가서 <code>Save</code>를 클릭하면 웹사이트가 완성된다.</p>
]]></content:encoded></item><item><title><![CDATA[블로그 만들기 GitHub 심화 3편 - 커스텀 도메인]]></title><description><![CDATA[<h1 id="">목차</h1>
<ul>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github/">블로그 만들기 GitHub 총정리</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-1/">블로그 만들기 GitHub 기본 1편 - 사용자 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-2/">블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</a></li>
<li><strong>블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</strong></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-4/">블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-5/">블로그 만들기 GitHub 심화 5편 - GitBook만들기</a></li>
</ul>
<hr><p>지난번 포스트에서 설명했지만 GitHub Pages 는</p>]]></description><link>https://blog.chulgil.me/how-to-make-blog-using-github-3/</link><guid isPermaLink="false">5c43c1f38db38e0001044cf3</guid><category><![CDATA[kr]]></category><category><![CDATA[BLOG]]></category><category><![CDATA[TIP]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Sun, 20 Jan 2019 22:08:48 GMT</pubDate><content:encoded><![CDATA[<h1 id="">목차</h1>
<ul>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github/">블로그 만들기 GitHub 총정리</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-1/">블로그 만들기 GitHub 기본 1편 - 사용자 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-2/">블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</a></li>
<li><strong>블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</strong></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-4/">블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-5/">블로그 만들기 GitHub 심화 5편 - GitBook만들기</a></li>
</ul>
<hr><p>지난번 포스트에서 설명했지만 GitHub Pages 는 아래와 같은 URL를 제공한다.</p>
<ul>
<li><code>username.github.io</code></li>
<li><code>username.github.io/project</code></li>
</ul>
<p>이번 포스트에서는 GitHub Pages를 자신이 가지고 있는 도메인으로 사용하고자 할때 설정방법을 공유한다.</p>
<ul>
<li><code>custom.domain.com</code></li>
</ul>
<hr><h2 id="">도메인 네임 등록</h2>
<p>보통 국내에서 많이 사용하는 도메인 네임서버는 아래와 같을 것이다.</p>
<ul>
<li><a href="https://www.gabia.com/">가비아</a></li>
<li><a href="http://www.whois.co.kr/">후이즈</a></li>
</ul>
<p>나의 경우는 미국에서 거주하고 있기 때문에 해외에서 많이 사용하는 도메인 네임서버를 사용하고 있다.</p>
<ul>
<li><a href="https://www.godaddy.com/">고대디(Goddady)</a></li>
<li><a href="https://www.name.com/">네임닷컴(Name.com)</a></li>
</ul>
<hr>
<h2 id="www">WWW서브도메인 권장</h2>
<p>GitHub에서는 아래와 같은 이유로 <code>www.domain.com</code> 와같이 www서브도메인을 사용하는것을 권장하고 있다.</p>
<ul>
<li>GitHub페이지 에서 <a href="https://en.wikipedia.org/wiki/Content_delivery_network">CDN(콘텐츠 전달 네트워크)</a>의 이점을 제공</li>
<li>GitHub서버의 IP주소가 변경되어도 영향을 받지 않아 안정적</li>
<li><a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">서비스 거부 공격</a>에 대한 방어가 구현되어 있어 페이지로드가 빨라짐</li>
</ul>
<table>
<thead>
<tr>
<th>권장 커스텀 도메인 타입</th>
<th>셈플 도메인</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>www</code> 서브도메인</strong></td>
<td><code>www.example.com</code></td>
</tr>
<tr>
<td><strong>루트도메인 &amp; one <code>www</code> 서브도메인</strong></td>
<td>
<code>example.com</code> &amp; <code>www.example.com</code>
</td>
</tr>
<tr>
<td>루트도메인</td>
<td><code>example.com</code></td>
</tr>
<tr>
<td>커스텀 서브도메인</td>
<td><code>blog.example.com</code></td>
</tr>
</tbody>
</table><hr><h2 id="a">도메인 네임서버에서 <code>A레코드</code> 로 설정하는 방법</h2>
<p><img src="https://blog.chulgil.me/content/images/2019/01/dnssetup_1.png" alt="dnssetup_1"><br>
DNS 레코드 타입에 A를 선택후 아래 IP대역에서 하나를 선택하여 data에 입력하면 완료된다.<br>
보통의 경우 사용자정의 서브도메인 구성을 블로그로 많이 사용하고 있다. <code>blog.domain.com</code></p>
<ul>
<li>185.199.108.153</li>
<li>185.199.109.153</li>
<li>185.199.110.153</li>
<li>185.199.111.153</li>
</ul>
<hr><h2 id="cname">도메인 네임서버에서 <code>CNAME레코드</code> 로 설정하는 방법</h2>
<p><img src="https://blog.chulgil.me/content/images/2019/01/dnssetup_2.png" alt="dnssetup_2"><br>
DNS레코드 타입에 CNAME을 선택후 아래와 같은 형식으로 data에 입력한다.</p>
<ul>
<li><code>username</code>.github.io</li>
</ul>
<hr><h2 id="dns">DNS레코드가 정상적으로 등록되었는지 확인하는 방법</h2>
<p>터미널에서 아래와같은 명령어로 등록한 도메인에 대한 IP포인트를 확인할 수 있다.</p>
<pre><code>$ dig +noall +answer blog.example.com
;example.com.
example.com.   3600  IN  A 185.199.108.153
example.com.   3600  IN  A 185.199.109.153
example.com.   3600  IN  A 185.199.110.153
example.com.   3600  IN  A 185.199.111.153
</code></pre>
<hr><h2 id="gibhubpages">GibHub Pages에서 커스텀 도메인 추가하기</h2>
<p>마지막으로 GitHub의 저장소에서 아래 설정만으로 커스텀도메인 구성이 완료된다.</p>
<ol>
<li>GitHub 저장소로 이동후 <code>Settings</code> 클릭</li>
<li>GitHub Pages의 Custom domain에 <code>blog.domain.com</code> 입력후 Save클릭</li>
</ol>
<p></p>]]></content:encoded></item><item><title><![CDATA[블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지]]></title><description><![CDATA[<h1 id="">목차</h1>
<ul>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github/">블로그 만들기 GitHub 총정리</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-1/">블로그 만들기 GitHub 기본 1편 - 사용자 페이지</a></li>
<li><strong>블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</strong></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-3/">블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-4/">블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-5/">블로그 만들기 GitHub 심화 5편 - GitBook만들기</a></li>
</ul>
<hr><h4 id="github-usernname-github-io-">GitHub 에서 블로그를 만들면 usernname.github.</h4>]]></description><link>https://blog.chulgil.me/how-to-make-blog-using-github-2/</link><guid isPermaLink="false">5c424f7b19a31400017ceb8c</guid><category><![CDATA[kr]]></category><category><![CDATA[BLOG]]></category><category><![CDATA[TIP]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Sun, 20 Jan 2019 00:09:22 GMT</pubDate><content:encoded><![CDATA[<h1 id="">목차</h1>
<ul>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github/">블로그 만들기 GitHub 총정리</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-1/">블로그 만들기 GitHub 기본 1편 - 사용자 페이지</a></li>
<li><strong>블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</strong></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-3/">블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-4/">블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-5/">블로그 만들기 GitHub 심화 5편 - GitBook만들기</a></li>
</ul>
<hr><h4 id="github-usernname-github-io-">GitHub 에서 블로그를 만들면 usernname.github.io 라는 도메인을 하나만 제공해서 결국 개인블로그만 운영할수밖에 없겠구나 생각했다.  하지만 멀티로 여러개의 사이트를 운영할 수 있는 방법이 있어 공유한다.</h4><hr><h2 id="-">사용자 페이지 와 프로젝트 페이지</h2><p>1편에서 만들었던 저장소의 이름이 <code>username.github.io</code> 로 된것을 <code>사용자 페이지</code>로 정의하고 있다.<br>즉 이름이 <code>another.github.io</code> 와 같이 다른계정이름이라면 표시되지 않는다.<br>그리고 master 브랜치에 내용이 곧 웹사이트에서 보이는 내용이 된다.</p><figure class="kg-card kg-image-card"><img src="https://blog.chulgil.me/content/images/2019/01/Blog7-2.jpeg" class="kg-image"></figure><p><br>이와 다르게 <code>프로젝트 페이지</code>는 프로젝트의 저장소를 그대로 사용한다. <br>즉 새로운 저장소를 만들 필요없이 GitHub프로젝트의 setting페이지에서 간단한 설정만으로 사용자 페이지와 같이 사이트 구축이 가능하다.<br>이렇게 생성된 페이지는 <code>username.github.com/projectname</code> 와 같은 URL로 생성된다.</p><p></p><figure class="kg-card kg-image-card"><img src="https://blog.chulgil.me/content/images/2019/01/Blog7-1.jpeg" class="kg-image"></figure><ul><li>Setting &gt; GitHub Pages &gt; Source &gt; master branch 에서 Save를 클릭하면 생성된다.  브랜치는 운영하고 싶은 브랜치로 설정가능하다.</li><li>기본제공되는 404에러페이지를 커스터마이징 하려면 커스텀 도메인을 사용해야한다.</li></ul><h3 id="--1">이렇게 프로젝트 별로 여러개의 사이트 운영이 가능하다.</h3><ul><li><code>username.github.com/project-1</code></li><li><code>username.github.com/project-2</code></li><li><code>username.github.com/project-3</code><br></li></ul><p><br></p>]]></content:encoded></item><item><title><![CDATA[블로그 만들기 GitHub기본 1편 - 사용자 페이지]]></title><description><![CDATA[<h1 id="">목차</h1>
<ul>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github/">블로그 만들기 GitHub 총정리</a></li>
<li><strong>블로그 만들기 GitHub 기본 1편 - 사용자 페이지</strong></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-2/">블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-3/">블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-4/">블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-5/">블로그 만들기 GitHub 심화 5편 - GitBook만들기</a></li>
</ul>
<hr><h3 id="github">이 글에서는 별도 프로그램 설치 없이</h3>]]></description><link>https://blog.chulgil.me/how-to-make-blog-using-github-1/</link><guid isPermaLink="false">5c4234af19a31400017ceb26</guid><category><![CDATA[BLOG]]></category><category><![CDATA[TIP]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Fri, 18 Jan 2019 21:53:48 GMT</pubDate><content:encoded><![CDATA[<h1 id="">목차</h1>
<ul>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github/">블로그 만들기 GitHub 총정리</a></li>
<li><strong>블로그 만들기 GitHub 기본 1편 - 사용자 페이지</strong></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-2/">블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-3/">블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-4/">블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-5/">블로그 만들기 GitHub 심화 5편 - GitBook만들기</a></li>
</ul>
<hr><h3 id="github">이 글에서는 별도 프로그램 설치 없이 Github 웹사이트에서 블로그를 만드는 방법을 소개한다.</h3>
<h5 id="github5">Github에 저장소를 만들고 기본 템플릿을 선택후 첫 글을 올리면 5분안에 블로그 설치가 완성된다.</h5>
<h5 id="1githubrepositoriesnew">1. Github에 로그인후 <code>Repositories</code>에 <code>New</code>버튼 클릭</h5>
<h5 id="2repositorynameuseridgithubiocreaterepository">2. Repository name에 <code>userid.github.io</code>를 입력후 <code>Create repository</code>클릭</h5>
<p><img src="https://blog.chulgil.me/content/images/2019/01/Blog6-1-1.jpeg" alt="블로그 만들기 GitHub기본 1편 - 사용자 페이지"></p>
<h5 id="3settinggithubpageschangetheme">3. 헤더에 <code>Setting</code> &gt; <code>GitHub Pages</code> &gt; <code>Change theme</code> 클릭후 원하는 테마를 선택하면</h5>
<p>편집창이 열리는데 맨 아랫 부분에 Commit 메세지를 넣어주고 <code>Commit changes</code>버튼을 클릭하면 <code>_config.yml</code>파일이 추가된것을 확인 할 수 있다.</p>
<pre><code>update README.md
</code></pre>
<figure class="kg-card kg-gallery-card kg-width-wide"><div class="kg-gallery-container"><div class="kg-gallery-row"><div class="kg-gallery-image"><img src="https://blog.chulgil.me/content/images/2019/01/Blog6-2-2.jpeg" width="800" height="616"></div><div class="kg-gallery-image"><img src="https://blog.chulgil.me/content/images/2019/01/Blog6-3-2.jpeg" width="800" height="616"></div></div><div class="kg-gallery-row"><div class="kg-gallery-image"><img src="https://blog.chulgil.me/content/images/2019/01/Blog6-5-1.jpeg" width="800" height="616"></div><div class="kg-gallery-image"><img src="https://blog.chulgil.me/content/images/2019/01/Blog6-4-2.jpeg" width="800" height="616"></div></div></div></figure><h5 id="4homecreatenewfilepostmd">4. <code>Home</code> &gt; <code>Create new file</code> 클릭후 <code>post.md</code> 를 추가한다음 편집창에서 마크다운 문법으로 작성후 저장한다.</h5>
<pre><code># Blog Post
## My first Blog Post
* Post1
* Post2
* Post3
</code></pre>
<figure class="kg-card kg-gallery-card kg-width-wide"><div class="kg-gallery-container"><div class="kg-gallery-row"><div class="kg-gallery-image"><img src="https://blog.chulgil.me/content/images/2019/01/Blog6-6.jpeg" width="800" height="650"></div><div class="kg-gallery-image"><img src="https://blog.chulgil.me/content/images/2019/01/Blog6-7.jpeg" width="800" height="650"></div></div></div></figure><h5 id="5usernamegithubio">5. <code>username.github.io</code> 로 접속하면 블로그가 만들어진 것을 확인할 수 있다.</h5>
<p><img src="https://blog.chulgil.me/content/images/2019/01/blog6-10.jpeg" alt="블로그 만들기 GitHub기본 1편 - 사용자 페이지"></p>
]]></content:encoded></item><item><title><![CDATA[블로그 만들기 GitHub 편 총정리]]></title><description><![CDATA[<p></p><h1 id="">목차</h1>
<ul>
<li><strong>블로그 만들기 GitHub 총정리</strong></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-1/">블로그 만들기 GitHub 기본 1편 - 사용자 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-2/">블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-3/">블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-4/">블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-5/">블로그 만들기 GitHub 심화 5편 - GitBook만들기</a></li>
</ul>
<hr><h2 id="githubpages">이 글에서는 왜 <a href="https://help.github.com/articles/what-is-github-pages/">GitHub Pages</a>를</h2>]]></description><link>https://blog.chulgil.me/how-to-make-blog-using-github/</link><guid isPermaLink="false">5c4208a219a31400017ce9cd</guid><category><![CDATA[kr]]></category><category><![CDATA[BLOG]]></category><category><![CDATA[TIP]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Fri, 18 Jan 2019 20:18:44 GMT</pubDate><content:encoded><![CDATA[<p></p><h1 id="">목차</h1>
<ul>
<li><strong>블로그 만들기 GitHub 총정리</strong></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-1/">블로그 만들기 GitHub 기본 1편 - 사용자 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-2/">블로그 만들기 GitHub 기본 2편 - 프로젝트 페이지</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-3/">블로그 만들기 GitHub 심화 3편 - 커스텀 도메인</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-4/">블로그 만들기 GitHub 심화 4편 - Jekyll 템플릿</a></li>
<li><a href="//blog.chulgil.me/how-to-make-blog-using-github-5/">블로그 만들기 GitHub 심화 5편 - GitBook만들기</a></li>
</ul>
<hr><h2 id="githubpages">이 글에서는 왜 <a href="https://help.github.com/articles/what-is-github-pages/">GitHub Pages</a>를 사용하면 어떤점이 좋은지, 활용하는 방법은 어떤것들이 있는지를 공유한다.</h2>
<p>GitHub Pages는 GitHub저장소의 내용을 호스팅해주기 때문에 및 웹서버 설치없이 공짜로 블로그를 쉽게 만들수 있다.<br>
원래 Git은 소스코드의 변경사항을 관리해주는 툴인데 온라인으로 소스코드를 관리할 수 있게 서비스해주는 곳이 GitHub이다.</p>
<p>최근 나를 포함한 많은 개발자들이 정적 사이트로 블로그를 발행하고 있다.</p>
<hr>
<h2 id="">그 이유는 다음과 같이 추려볼 수 있다.</h2>
<ol>
<li>설치형 블로그를 운영하다가 트래픽 증가로 인한 서버관리를 지속하기가 힘들다.</li>
<li>SQL injection같은 보안이슈를 생각하고 싶지 않다.</li>
<li>호스팅업체에 매월 나가는 돈이 아깝다.</li>
<li>효율적인 SEO를 위해서는 웹사이트의 스피드가 중요한데 속도 또한 빠르다.</li>
<li>Markdown 을 이용해서 디자인에 신경쓰지 않고 글쓰기에 집중할 수 있다.</li>
<li>HTML로 만들어진 문서를 배포하기 쉽다.(아마존S3, 저비용호스팅, 개인서버)</li>
<li>Jekyll을 Github CEO가 만들었기 때문에 github에서는 이미 지원하고 있다.</li>
<li>Visual Code와 같은 개발툴로도 작성할수 있기때문에 회사에서도 눈치보지 않고 포스팅이 가능하다.</li>
<li><a href="http://tech.kakao.com/2016/07/07/tech-blog-story/">kakao기술 블로그</a>와 같이 대기업들도 활용하고 있는 곳이 많다.</li>
<li>백엔드 서버언어를 사용하지 않고 정적파일들로 호스팅을 제공 하기때문에 html, css, javascript를 이용해서 쉽게 웹사이트를 만들고 도메인까지 붙일 수있다.</li>
<li>Git와 같은 버전관리 프로그램을 통한 편집이력 관리도 용이하다.</li>
</ol>
<hr><p>확실히 개인 블로그로만 활용한다고 하면 이렇게 효율성 좋은 서비스는 찾아보기 어렵다.<br>
글을 작성하는 사람이 본인이기 때문에 로그인인증도 필요없고 내가 글을 작성하는 시점에<br>
웹에 보여지기만 하면 되는 것이기때문에 동적인 플랫폼을 사용하는 것보다 본래의 HTML을<br>
제공한다면 관리하기도 쉽다.<br>
거기다가 루비기반으로 만들어진 Jekyll과 같은 사이트생성기를 사용하면<br>
Header와 Footer같이 반복되는 페이지들도 스플릿트할수가 있다.</p>
<h2 id="">사용하기 꺼려하는 이유</h2>
<p>이런 장점에도 불구하고 사용하기 꺼려하는 이유가 있는데 다음과 같다.</p>
<ol>
<li>Markdown을 공부하기 귀찮다.</li>
<li>사이트 구조의 개선이 어렵다.</li>
<li>댓글기능이 제공되지 않아 써드파티 서비스를(Disqus) 이용 해야만한다.</li>
<li>상기 댓글과 같은 사용자 데이터를 확보하기 힘들다.</li>
<li>검색기능 구현이 까다롭다.</li>
<li>너무 개발자 스럽다.</li>
</ol>
<p>블로그에 글을 쓸경우 보통의 동적플랫폼은 Admin패널에 가서 글쓰기를 하면된다지만<br>
정적 블로그 생성기를 사용하는 경우는 일반인 입장에서는 까다롭다.<br>
Admin패널처럼 이용하려면</p>
<ol>
<li>github에 가서 파일을 생성하고 commit을 하거나</li>
<li>본인의 컴퓨터에서 문서를 작성하고 git push를 하는것과 같다.</li>
</ol>
<hr>
<h2 id="">결론</h2>
<p>개인적으로 활용해본 결과 동적 플랫폼으로 만들어 놓은 사이트는 구축및 운영에서 힘들었는데<br>
Github Pages와 같은 정적사이트호스팅을 이용하면 설치도 쉬웠고 글을 올리는과정을 제외하고는<br>
웹사이트 관리및 운영이슈는 딱히 없어서 편했기 때문에 블로그를 시작하시는 분들에게 적극 추천드린다.</p>
]]></content:encoded></item><item><title><![CDATA[MAC에서 기본툴로 이미지 리사이징 하는법]]></title><description><![CDATA[<h4 id="macospreview">최근 블로그를 작성 중 이미지를 올리려는데 일관성을 유지하기 위해 이미지 사이즈를 조절하려했는데 MacOS의 Preview기본 툴로도 리사이징이 가능해서 그 방법을 공유한다.</h4>
<blockquote>
<p>참고로 간단한 리사이징은 포토샵과 같은 유료사진 편집프로그램을 사용하기보다 간편하게 기본툴을 사용하는것이 개인적으로는 편하다.</p>
</blockquote>
<hr><h2 id="">이미지 크기를 조절하는 방법</h2>
<ol>
<li>파인더(Finder)에서 이미지를 더블클릭하면 Preview에서 이미지가 열림</li>
<li>도구(Tool)에에서 크기조정(Adjust</li></ol>]]></description><link>https://blog.chulgil.me/how-to-resizing-image-using-macos/</link><guid isPermaLink="false">5c3ffc2119a31400017ce948</guid><category><![CDATA[kr]]></category><category><![CDATA[TIP]]></category><category><![CDATA[MAC]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Thu, 17 Jan 2019 18:01:20 GMT</pubDate><content:encoded><![CDATA[<h4 id="macospreview">최근 블로그를 작성 중 이미지를 올리려는데 일관성을 유지하기 위해 이미지 사이즈를 조절하려했는데 MacOS의 Preview기본 툴로도 리사이징이 가능해서 그 방법을 공유한다.</h4>
<blockquote>
<p>참고로 간단한 리사이징은 포토샵과 같은 유료사진 편집프로그램을 사용하기보다 간편하게 기본툴을 사용하는것이 개인적으로는 편하다.</p>
</blockquote>
<hr><h2 id="">이미지 크기를 조절하는 방법</h2>
<ol>
<li>파인더(Finder)에서 이미지를 더블클릭하면 Preview에서 이미지가 열림</li>
<li>도구(Tool)에에서 크기조정(Adjust )클릭</li>
<li>동일한 비율로 조절하려면 Scale proportionally를 체크하면된다.</li>
<li>만약 프린트를 해야하는 경우라면 최상의 해상도를 유지하기 위해서 300dpi설정해 주는것을 잊지말자.</li>
</ol>
<p><img src="https://blog.chulgil.me/content/images/2019/01/blogPost4.jpg" alt="blogPost4"></p>
<hr><h2 id="">이미지 용량을 줄이는 방법</h2>
<p>이메일로 이미지를 첨부할때 용량문제로 이미지가 첨부되지 않는다면 이미지를 줄여서 보낼때 사용한다.</p>
<ol>
<li>파일 내보내기 클릭 : Previe-&gt;File-&gt;Export</li>
<li>다음과 같은 순으로 용량이 가장 적은 JPEG를 선택한다.</li>
</ol>
<ul>
<li><code>TIFF &gt; PNG &gt; JPEG</code></li>
</ul>
<p><img src="https://blog.chulgil.me/content/images/2019/01/BlogPost4_imageResize.jpg" alt="BlogPost4_imageResize"></p>
<p>※ <a href="https://ko.wikipedia.org/wiki/JPEG_2000">JPEG2000</a>은 압축률이 더 좋으나 <a href="https://caniuse.com/#feat=jpeg2000">브라우저 지원</a>문제를 확인해보고 선택하자.</p>
<hr><h2 id="">이미지 품질 저하없이 크기 조절하기</h2>
<p>원본이미지가 작은데 더 큰 사이즈로 이미지 크기를 조정하려고 하면 이미지품질이 저하된다.</p>
<p>이경우 HEIC파일 포멧으로 저장하면 품질이 비슷한 이미지를 만들수가 있는데 아쉽게도<br>
High Sierra 또는 Mojave가 설치된 맥에서만 볼수 있다.</p>
<figure class="kg-card kg-gallery-card kg-width-wide"><div class="kg-gallery-container"><div class="kg-gallery-row"><div class="kg-gallery-image"><img src="https://blog.chulgil.me/content/images/2019/01/blogPost4_before-1.jpg" width="1192" height="868"></div><div class="kg-gallery-image"><img src="https://blog.chulgil.me/content/images/2019/01/blogPost4_after.jpg" width="800" height="580"></div></div></div><figcaption>Before After</figcaption></figure><hr><h2 id="">일괄 사이즈 조절</h2>
<p>한꺼번에 10장의 사진을 조절하는 경우 시간이 많이 걸린다. 이럴경우 아래와 같이 한번에 조절 가능하다.</p>
<ol>
<li>Command키를 누른 상태에서 복수이미지를 선택한다.</li>
<li>마우스 우클릭으로 열기를 선택하면 기본 Preview창에 복수 이미지가 열린다.</li>
<li>위와 같은 방법으로 툴에서 크기조절로 일괄조절이 가능하다.</li>
</ol>
<p><img src="https://blog.chulgil.me/content/images/2019/01/BlogPost4_all.jpg" alt="BlogPost4_all"></p>
]]></content:encoded></item></channel></rss>