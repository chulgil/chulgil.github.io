<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[CODE - CG.Lee Blog]]></title><description><![CDATA[Thoughts, stories and ideas.]]></description><link>https://blog.chulgil.me/</link><image><url>https://blog.chulgil.me/favicon.png</url><title>CODE - CG.Lee Blog</title><link>https://blog.chulgil.me/</link></image><generator>Ghost 2.10</generator><lastBuildDate>Mon, 11 Feb 2019 19:29:10 GMT</lastBuildDate><atom:link href="https://blog.chulgil.me/tag/code/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[알고리즘의 시간 복잡도와 Big-O 쉽게 이해하기]]></title><description><![CDATA[<p>삼성역에서 택시를 타고 강남역으로 향했는데 30분 걸렸다. 구글에서 알려주는 최단경로로 갔더라면 15분내에 도착할 것이다. 레스토랑을 예약해서 가는 경우라던지 친구와 약속시간을 잡은경우 우리에게는 시간은 항상 소중하다. 그래서 우리는 시간을 효율적으로 사용하기위한 노력을 의식적으로 하고 있다.<br>
컴퓨터 프로그래밍에서도 시간복잡도가 가장 낮은 알고리즘을 채택해 이러한 상황을 개선하고 있다. 택시를 타고 삼성역까지 가는 절차를</p>]]></description><link>https://blog.chulgil.me/algorithm/</link><guid isPermaLink="false">5c5b68b28db38e000104539e</guid><category><![CDATA[kr]]></category><category><![CDATA[CODE]]></category><category><![CDATA[ALGORITHM]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Thu, 07 Feb 2019 19:52:40 GMT</pubDate><content:encoded><![CDATA[<p>삼성역에서 택시를 타고 강남역으로 향했는데 30분 걸렸다. 구글에서 알려주는 최단경로로 갔더라면 15분내에 도착할 것이다. 레스토랑을 예약해서 가는 경우라던지 친구와 약속시간을 잡은경우 우리에게는 시간은 항상 소중하다. 그래서 우리는 시간을 효율적으로 사용하기위한 노력을 의식적으로 하고 있다.<br>
컴퓨터 프로그래밍에서도 시간복잡도가 가장 낮은 알고리즘을 채택해 이러한 상황을 개선하고 있다. 택시를 타고 삼성역까지 가는 절차를 알고리즘이라고 하는데 이때 수행하는 연산의 수를 시간복잡도로 나타낸다. 택시를 타고 강남역까지 가는 과정을 알고리즘으로 표현하면 아래와 같다.</p>
<pre><code>function TakeTaxy(from, to) {
/*
 1. 차량에 탑승한다.
 2. from에서 to까지 최단거리 루트를 선택한다.
 3.   목적지까지 가는 루트을 설명한다.
 4.   출퇴근 시간의 경우 차가 막히는 루트는 피한다.
 5. 출발하는동안
 6.   만약 적색 신호등이면 정지한다.
 7.   만약 녹색 신호등이면 출발한다.
 8. 도착하면
 9.   요금을 정산한다.
 10. 차량에서 내린다.
*/
}
</code></pre>
<p>따라서 알고리즘이란</p>
<ul>
<li>어떤 목적을 달성하거나 결과물을 만들어내기 위해 거쳐야 하는 일련의 과정들을 의미한다.</li>
<li>가는 루트는 다양하며 여러가지 상황에 따른 알고리즘은 모두 다르다. 따라서 시간복잡도가 가장 낮은 알고리즘을 선택하여 사용한다.</li>
</ul>
<p>여기서 알고리즘의 실행시간은 컴퓨터가 알고리즘 코드를 실행하는 속도에 의존한다.<br>
이 속도는 컴퓨터의 처리속도, 사용된 언어종류, 컴파일러의 속도에 달려있다.</p>
<p>알고리즘의 실행시간을 두 부분으로 나누면</p>
<ol>
<li>입력값의 크기에 따라 알고리즘의 실행시간을 검증해볼 수 있다.</li>
<li>입력값의 크기에 따른 함수의 증가량, 우리는 이것을 성장률이라고 부른다.<br>
이때 중요하지 않는 상수와 계수들을 제거하면 알고리즘의 실행시간에서 중요한<br>
성장률에 집중할 수있는데 이것을 점금적 표기법(Asymptotic notation)이라 부른다.<br>
여기서, 점근적이라는 의미는 가장 큰 영향을 주는 항만 계산한다는 의미다.</li>
</ol>
<p>점근적 표기법은 다음 세가지가 있는데 시간복잡도를 나타내는데 사용된다.</p>
<ul>
<li>최상의 경우 : 오메가 표기법 (Big-Ω Notation)</li>
<li>평균의 경우 : 세타 표기법 (Big-θ Notation)</li>
<li>최악의 경우 : 빅오 표기법 (Big-O Notation)</li>
</ul>
<p>평균인 세타 표기를 하면 가장 정확하고 좋겠지만 평가하기가 까다롭다.<br>
그래서 최악의 경우인 빅오를 사용하는데 알고리즘이 최악일때의 경우를 판단하면 평균과 가까운 성능으로 예측하기 쉽기때문이다.</p>
<h2 id="bigo">빅오 표기법(Big-O)</h2>
<p>빅오 표기법은 불필요한 연산을 제거하여 알고리즘분석을 쉽게 할 목적으로 사용된다.</p>
<p>Big-O로 측정되는 복잡성에는 시간과 공간복잡도가 있는데</p>
<ul>
<li>시간복잡도는 입력된 N의 크기에 따라 실행되는 조작의 수를 나타낸다.</li>
<li>공간복잡도는 알고리즘이 실행될때 사용하는 메모리의 양을 나타낸다.<br>
요즘에는 데이터를 저장할 수 있는 메모리의 발전으로 중요도가 낮아졌다.</li>
<li>아래는 대표적인 Big-O의 복잡도를 나타내는 표이다.</li>
</ul>
<hr>
<figure class="kg-card kg-image-card kg-width-full"><img src="https://blog.chulgil.me/content/images/2019/02/Screen-Shot-2019-02-07-at-2.31.54-PM-1.png" class="kg-image"><figcaption>http://bigocheatsheet.com/</figcaption></figure><h2 id="">시간복잡도</h2>
<p>시간복잡도의 가장 간단한 정의는 알고리즘의 성능을 설명하는 것이다.<br>
다른의미로는 알고리즘을 수행하기 위해 프로세스가 수행해야하는 연산을 수치화 한것이다.<br>
왜 실행시간이 아닌 연산수치로 판별할까? 위에도 설명했지만 명령어의 실행시간은 컴퓨터의 하드웨어 또는 프로그래밍 언어에 따라 편차가 크게 달라지기 때문에 명령어의 실행 횟수만을 고려하는 것이다.</p>
<p>시간복잡도에서 중요하게 보는것은 가장큰 영향을 미치는 n의 단위이다.</p>
<pre><code>1             O(1)   --&gt; 상수
2n + 20       O(n)   --&gt; n이 가장 큰영향을 미친다.
3n^2          O(n^2) --&gt; n^2이 가장 큰영향을 미친다.
</code></pre>
<p>시간복잡도의 문제해결 단계를 나열 하면 아래와같다.</p>
<pre><code>O(1) – 상수 시간 : 문제를 해결하는데 오직 한 단계만 처리함.
O(log n) – 로그 시간 : 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듬.
O(n) – 직선적 시간 : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가짐.
O(n log n) : 문제를 해결하기 위한 단계의 수가 N*(log2N) 번만큼의 수행시간을 가진다. (선형로그형)
O(n^2) – 2차 시간 : 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱.
O(C^n) – 지수 시간 : 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱.
</code></pre>
<p>아래표는 실행시간이 빠른순으로 입력 N값에 따른 서로 다른 알고리즘의 시간복잡도이다.</p>
<table>
<thead>
<tr>
<th>Complexity</th>
<th>1</th>
<th>10</th>
<th>100</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(1)</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>O(log N)</td>
<td>0</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>O(N)</td>
<td>1</td>
<td>10</td>
<td>100</td>
</tr>
<tr>
<td>O(N log N)</td>
<td>0</td>
<td>20</td>
<td>461</td>
</tr>
<tr>
<td>O(N^2)</td>
<td>1</td>
<td>100</td>
<td>10000</td>
</tr>
<tr>
<td>O(2^N)</td>
<td>1</td>
<td>1024</td>
<td>1267650600228229401496703205376</td>
</tr>
<tr>
<td>O(N!)</td>
<td>1</td>
<td>3628800</td>
<td>화면에 표현할 수 없음!</td>
</tr>
</tbody>
</table><h3 id="o1">O(1) : 상수</h3>
<p>아래 예제 처럼 입력에 관계없이 복잡도는 동일하게 유지된다.</p>
<pre><code>def hello_world():
        print(&quot;hello, world!&quot;)
</code></pre>
<h3 id="on">O(N) : 선형</h3>
<p>입력이 증가하면 처리 시간또는 메모리 사용이 선형적으로 증가한다.</p>
<pre><code>def print_each(li):
    for item in li:
        print(item)
</code></pre>
<h3 id="on2square">O(N^2) : Square</h3>
<p>반복문이 두번 있는 케이스</p>
<pre><code>def print_each_n_times(li):
    for n in li:
        for m in li:
            print(n,m)
</code></pre>
<h3 id="olognonlogn">O(log n) O(n log n)</h3>
<p>주로 입력 크기에 따라 처리 시간이 증가하는 정렬알고리즘에서 많이 사용된다.<br>
다음은 이진검색의 예이다.</p>
<pre><code>def binary_search(li, item, first=0, last=None):
	if not last:
		last = len(li)

	midpoint = (last - first) / 2 + first

	if li[midpoint] == item:
		return midpoint

	elif li[midpoint] &gt; item:
		return binary_search(li, item, first, midpoint)

	else:
		return binary_search(li, item, midpoint, last)

</code></pre>
<h2 id="">시간복잡도를 구하는 요령</h2>
<p>각 문제의 시간복잡도 유형을 빨리 파악할 수 있도록 아래 예를 통해 빠르게 알아 볼수 있다.</p>
<ul>
<li>하나의 루프를 사용하여 단일 요소 집합을 반복 하는 경우 : O (n)</li>
<li>컬렉션의 절반 이상 을 반복 하는 경우 :  O (n / 2) -&gt; O (n)</li>
<li>두 개의 다른 루프를 사용하여 두 개의 개별 콜렉션을 반복 할 경우 : O (n + m) -&gt; O (n)</li>
<li>두 개의 중첩 루프를 사용하여 단일 컬렉션을 반복하는 경우 : O (n²)</li>
<li>두 개의 중첩 루프를 사용하여 두 개의 다른 콜렉션을 반복 할 경우 : O (n * m) -&gt; O (n²)</li>
<li>컬렉션 정렬을 사용하는 경우 : O(n*log(n))</li>
</ul>
<p></p><h2 id="-">정렬 알고리즘 비교</h2> <table>
         <thead>
            <tr role="row">
               <th rowspan="2" data-column="0" tabindex="0" scope="col" role="columnheader" aria-disabled="false"><div>Sorting Algorithms</div></th>
               <th>공간 복잡도</th>
               <th><div>시간 복잡도</div></th>
            </tr>

            <tr role="row">
               <th data-column="1"><div>최악</div></th>
               <th data-column="2"><div>최선</div></th>
               <th data-column="3"><div>평균</div></th>
               <th data-column="4"><div>최악</div></th>
            </tr>
         </thead>

         <tbody aria-live="polite" aria-relevant="all">
         <tr role="row">
               <td>Bubble Sort</td>
               <td data-text="1">O(1)</td>

               <td data-text="3">O(n)</td>
               <td data-text="5">O(n<sup>2</sup>)
               </td>
               <td data-text="5">O(n<sup>2</sup>)
               </td>
            </tr><tr role="row">
               <td>Heapsort</td>
               <td data-text="1">O(1)</td>

               <td data-text="4">O(n log n)</td>
               <td data-text="4">O(n log n)</td>
               <td data-text="4">O(n log n)</td>
            </tr><tr role="row">
               <td>Insertion Sort</td>
               <td data-text="1">O(1)</td>

               <td data-text="3">O(n)</td>
               <td data-text="5">O(n<sup>2</sup>)
               </td>
               <td data-text="5">O(n<sup>2</sup>)
               </td>
            </tr><tr role="row">

               <td>Mergesort</td>
               <td data-text="3">O(n)</td>

               <td data-text="4">O(n log n)</td>
               <td data-text="4">O(n log n)</td>
               <td data-text="4">O(n log n)</td>

            </tr><tr role="row">

               <td>Quicksort</td>
               <td data-text="2">O(log n)</td>

               <td data-text="4">O(n log n)</td>
               <td data-text="4">O(n log n)</td>
               <td data-text="4">O(n log n)</td>

            </tr><tr role="row">
               <td>Selection Sort</td>
               <td data-text="1">O(1)</td>

               <td data-text="5">O(n<sup>2</sup>)
               </td>
               <td data-text="5">O(n<sup>2</sup>)
               </td>
               <td data-text="5">O(n<sup>2</sup>)
               </td>
            </tr><tr role="row">
               <td>Shell Sort</td>
               <td data-text="1">O(1)</td>

               <td data-text="3">O(n)</td>
               <td data-text="6">O(n log n<sup>2</sup>)
               </td>
               <td data-text="6">O(n log n<sup>2</sup>)
               </td>
            </tr><tr role="row">
               <td>Smooth Sort</td>
               <td data-text="1">O(1)</td>

               <td data-text="3">O(n)</td>
               <td data-text="4">O(n log n)</td>
               <td data-text="4">O(n log n)</td>

            </tr></tbody>

      </table><hr><h2 id="--1">자료구조 비교</h2>
      <table>
         <thead>
            <tr role="row">
               <th rowspan="2" data-column="0" tabindex="0" scope="col" role="columnheader" aria-disabled="false"><div>Data  Structures</div></th>
               <th colspan="3"><div>Average Case</div></th>
               <th colspan="3">Worst Case</th>
            </tr>
            <tr role="row">
               <th data-column="1">Search</th>
               <th data-column="2">Insert</th>
               <th data-column="3">Delete</th>
               <th data-column="4">Search</th>
               <th data-column="5">Insert</th>
               <th data-column="6">Delete</th>
            </tr>
         </thead>

         <tbody aria-live="polite" aria-relevant="all">
            <tr role="row">
               <td>Array</td>
               <td>O(n)</td>
               <td>N/A</td>
               <td>N/A</td>
               <td>O(n)</td>
               <td>N/A</td>
               <td>N/A</td>
            </tr>
            <tr role="row">
               <td>Sorted Array</td>
               <td>O(log
                  n)</td>
               <td>O(n)</td>
               <td>O(n)</td>
               <td>O(log
                  n)</td>
               <td>O(n)</td>
               <td>O(n)</td>
            </tr>
            <tr role="row">
               <td>Linked List</td>
               <td>O(n)</td>
               <td>O(1)</td>
               <td>O(1)</td>
               <td>O(n)</td>
               <td>O(1)</td>
               <td>O(1)</td>
            </tr>
            <tr role="row">
               <td>Doubly Linked List</td>
               <td>O(n)</td>
               <td>O(1)</td>
               <td>O(1)</td>
               <td>O(n)</td>
               <td>O(1)</td>
               <td>O(1)</td>
            </tr>
            <tr role="row">
               <td>Stack</td>
               <td>O(n)</td>
               <td>O(1)</td>
               <td>O(1)</td>
               <td>O(n)</td>
               <td>O(1)</td>
               <td>O(1)</td>
            </tr>
            <tr role="row">
               <td>Hash table</td>
               <td>O(1)</td>
               <td>O(1)</td>
               <td>O(1)</td>
               <td>O(n)</td>
               <td>O(n)</td>
               <td>O(n)</td>
            </tr>
            <tr role="row">
               <td>Binary Search Tree</td>
               <td>O(log
                  n)</td>
               <td>O(log

                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(n)</td>
               <td>O(n)</td>
               <td>O(n)</td>
            </tr>
            <tr role="row">
               <td>B-Tree</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
            </tr>
            <tr role="row">
               <td>Red-Black tree</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
            </tr>
            <tr role="row">
               <td>AVL Tree</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
               <td>O(log
                  n)</td>
            </tr>

         </tbody>
      </table>]]></content:encoded></item><item><title><![CDATA[[LeetCode] #263 - Ugly Number]]></title><description><![CDATA[<h3 id="">주어진 문제는 아래와 같다.</h3>
<hr>
<p>난의도 : ★★☆☆☆</p>
<p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.</p>
<p>Note:</p>
<p>1 is typically treated as an ugly number.<br>
Input is within the 32-bit signed integer range: [−2^31,</p>]]></description><link>https://blog.chulgil.me/leetcode-263/</link><guid isPermaLink="false">5c5b02f58db38e000104535a</guid><category><![CDATA[kr]]></category><category><![CDATA[CODE]]></category><category><![CDATA[ALGORITHM]]></category><category><![CDATA[LeetCode]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Wed, 06 Feb 2019 23:04:11 GMT</pubDate><content:encoded><![CDATA[<h3 id="">주어진 문제는 아래와 같다.</h3>
<hr>
<p>난의도 : ★★☆☆☆</p>
<p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.</p>
<p>Note:</p>
<p>1 is typically treated as an ugly number.<br>
Input is within the 32-bit signed integer range: [−2^31,  2^31 − 1].</p>
<pre><code>Input: 6
Output: true
Explanation: 6 = 2 × 3

Output: true
Explanation: 8 = 2 × 2 × 2

Input: 14
Output: false 
Explanation: 14 is not ugly since it includes another prime factor 7.
</code></pre>
<hr>
<h2 id="">분석하기</h2>
<p>즉 입력받은 숫자가 소수(factors)이고 소인수(prime factors)가 2, 3, 5중에 하나이면  True 아니면 False 를 반환해주는 문제이다.</p>
<p>먼저 소수가 무엇인지 알아보면 나눠지는 수 즉 약수(divisor)가 1과 자기 자신인 수이다.<br>
<code>EX) 2, 3, 5, 7, 11, 13, 17</code></p>
<p>즉 2 부터 N - 1까지 순서대로 정수로 나눠서 떨어지는 수가 없으면 소수인데<br>
이 문제의 경우 [2, 3, 5]를 순서대로 계속 나눠서 최종적으로 떨어지는 수가 1인경우 True를 반환하면 된다.</p>
<h2 id="">코드로 구현하기 (파이썬)</h2>
<pre><code>class Solution:
    def isUgly(self, num: 'int') -&gt; 'bool':
        if num is 0 : return False
        for i in [2, 3, 5] :
            while num % i is 0:
                num = num // i
        return num is 1
</code></pre>
<p>시간 복잡도는 O(log n)이 되겠다.</p>
]]></content:encoded></item><item><title><![CDATA[토큰기반 인증 파헤치기(AngularJS & Node.js )]]></title><description><![CDATA[<hr>
<h3 id="">토큰 기반 인증 시스템을 설명하기 전에, 먼저 전통적인 인증 시스템을 살펴보자.</h3>
<p><img src="https://blog.chulgil.me/content/images/2019/02/token.png" alt="token"></p>
<ol>
<li>사용자는 username과 password를 로그인 폼에 입력하고 Login 버튼을 클릭한다.</li>
<li>서버는 요청이 들어오면 DB를 쿼리하여 user를 검증한다. 만약 요청이 유효하면 세션을 생성하고 세션 정보를 Response 헤더에 포함시켜 반환한다.</li>
<li>클라이언트는 제한된 end points에 접근할 때 모든 Request Header에 세션 정보를 포함시킨다.</li></ol>]]></description><link>https://blog.chulgil.me/token-based-authentication-with-angularjs/</link><guid isPermaLink="false">5c58c3e38db38e000104533e</guid><category><![CDATA[kr]]></category><category><![CDATA[CODE]]></category><category><![CDATA[TIP]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Tue, 05 Feb 2019 10:00:00 GMT</pubDate><content:encoded><![CDATA[<hr>
<h3 id="">토큰 기반 인증 시스템을 설명하기 전에, 먼저 전통적인 인증 시스템을 살펴보자.</h3>
<p><img src="https://blog.chulgil.me/content/images/2019/02/token.png" alt="token"></p>
<ol>
<li>사용자는 username과 password를 로그인 폼에 입력하고 Login 버튼을 클릭한다.</li>
<li>서버는 요청이 들어오면 DB를 쿼리하여 user를 검증한다. 만약 요청이 유효하면 세션을 생성하고 세션 정보를 Response 헤더에 포함시켜 반환한다.</li>
<li>클라이언트는 제한된 end points에 접근할 때 모든 Request Header에 세션 정보를 포함시킨다.</li>
<li>만약 세션 정보가 유효하면 서버는 사용자가 특정 end point에 접근하는 것을 허용하고 렌더링된 HTML 내용을 반환한다.</li>
</ol>
<p>여기까지는 문제가 없다. 웹 어플리케이션은 잘 동작하고, 사용자 인증을 거쳐서 특정 endpoint로의 접근을 제한할 수 있다. 하지만 안드로이드와 같은 다른 클라이언트에서 동작하는 어플리케이션을 만들고 싶다면 어떨까? 전통적인 인증 방식으로 동작하는 어플리케이션을 모바일 클라이언트에서도 동일하게 사용할 수 있을까? 그렇지 않다. 그 이유는 다음과 같다.</p>
<ol>
<li>세션과 쿠키는 모바일 어플리케이션에서 make sense하지 않다. 서버에서 생성된 세션과 쿠키를 모바일 클라이언트에서는 공유할 수 없다.</li>
<li>현재 어플리케이션에서 렌더링된 HTML이 반환되었다. 모바일 클라이언트에서는 JSON 또는 XML와 같은 포맷의 응답이 필요하다.<br>
이러한 경우 클라이언트 독립적인 어플리케이션 이 필요하다.</li>
</ol>
<p>So, what is this JWT?</p>
<hr>
<h3 id="jwt">JWT</h3>
<p>JWT는 JSON Web Token의 약자이며 인증 헤더 내에서 사용되는 토큰 포맷이다. 이 토큰은 두 개의 시스템끼리 안전한 방법으로 통신할 수 있도록 설계하는 것을 도와준다. 이 튜토리얼에서는 JWT를 &quot;Bearer 토큰&quot;으로 부르도록 하겠다. Bearer 토큰은 3가지 요소로 구성된다 : Header, Payload, Signature.</p>
<p>Header는 토큰 타입과 암호화 방법을 보관하는 토큰의 한 부분이며, Base-64로 인코딩된다.<br>
Payload에는 유저 정보, 상품 정보 등의 다양한 종류의 정보를 넣을 수 있다. Base-64로 인코딩된다.<br>
Signature는 Header, Payload, Secret key의 조합이다. Secret key는 반드시 서버에 안전하게 보관되어야 한다.</p>
<p>JTW의 장점은 계정 서버와 API 서버가 분리되어 있을 때, API 서버가 계정 서버에게 토큰의 유효성 여부를 물어보지 않고도 스스로 판단할 수 있다는 것이다.</p>
<p>JWT 스키마와 토큰 예제는 아래와 같다.</p>
<p><img src="https://blog.chulgil.me/content/images/2019/02/token2.png" alt="token2"></p>
<p>몇가지 언어에서 이미 구현되어 있기 때문에 Bearer 토큰을 생성하는 코드를 직접 구현할 필요는 없다.</p>
<pre><code>###### Language Livbary URL 

 - NodeJS : http://github.com/auth0/node-jsonwebtoken  
 - PHP : http://github.com/firebase/php-jwt  
 - Java : http://github.com/auth0/java-jwt  
 - Ruby : http://github.com/progrium/ruby-jwt  
 - .NET : http://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet  
 - Python : http://github.com/progrium/pyjwt/  

</code></pre>
<hr>
<h3 id="">예제 살펴보기</h3>
<p>토큰 기반 인증에 대해 몇가지 기본 정보를 다뤘기 때문에 이제 연습 예제를 진행해보자. 아래 스키마를 잘 봐두길 바란다.</p>
<p><img src="https://blog.chulgil.me/content/images/2019/02/token3.png" alt="token3"></p>
<ol>
<li>API에 대한 요청은 여러 클라이언트에 의해 생성된다. (웹 어플리케이션, 모바일 클라이언트, ...)</li>
<li>요청은 <a href="https://api.yourexampleapp.xn--com-rg8l">https://api.yourexampleapp.com과</a> 같은 서비스에게 전달된다. 많은 사람들이 어플리케이션을 사용하면 요청을 수행하기 위해 여러개의 서버가 필요할 것이다.</li>
<li>여기서 가장 적합한 서버로 요청하기 위해 로드 밸런서가 사용된다. <a href="https://api.yourexamplapp.xn--com-ky7m580d">https://api.yourexamplapp.com으로</a> 요청 발생하면 먼저 로드 밸런서가 요청을 제어하고 특정 서버로 클라이언트를 redirect 시킨다.</li>
<li>하나의 어플리케이션이 있고 이 어플리케이션은 여러 서버로 배치된다 (server-1, server-2, ..., server-n). 요청이 만들어질 때마다 백엔드 어플리케이션은 요청 헤더를 가로채서 인증 헤더 내의 토큰 정보를 추출해낸다. DB 쿼리는 이 토큰을 사용하여 만들어질 것이다. 만약 토큰이 유효하고 end point에 접근하기 위해 요구되는 권한을 갖고 있다면 문제없이 진행될 것이다. 만약 그렇지 않다면 403 응답 코드(forbidden status)를 반환할 것이다.</li>
</ol>
<hr>
<h3 id="">토큰기반 인증의 장점</h3>
<p>토큰 기반 인증은 심각한 문제들을 해결해주는 몇가지 이점을 갖는다. 그 중 일부는 아래와 같다.</p>
<ul>
<li>
<p>클라이언트 독립적인 서비스. 토큰 기반 인증에서 토큰은 요청 헤더를 통해 전달된다. 이것은 stateless를 의미한다. HTTP 요청을 만들 수 있는 클라이언트라면 누구든지 서버로 요청을 보낼 수 있다.</p>
</li>
<li>
<p>CDN. 대부분의 현재 웹 어플리케이션 내에서 view는 백엔드 상에서 렌더링되고 브라우저로 HTML이 반환된다. 프론트엔드의 로직이 백엔드 코드와 의존성이 있는 것이다. 이렇게 의존성이 생기면 몇가지 문제가 발생한다. 예를 들어, 프론트엔드 HTML, CSS, JS 등을 구현하는 디자인 에이전시와 함께 일을 한다고 가정해보자. 우리는 일부 렌더링 또는 생성 동작을 수행하기 위해 프론트엔드 코드를 가져와서 백엔드 코드에 통합시켜야 한다. 어쩌면 렌더링된 HTML 컨텐츠는 디자인 에이전시가 구현했던 것과 아주 많이 다를 것이다. 토큰 기반 인증에서는 프론트엔드 프로젝트를 백엔드로부터 독립적으로 개발하도록 할 수 있다. 백엔드 코드는 렌더링된 HTML 대신 JSON 응답을 반환할 것이고, 경량화되고 압축된 버전의 프론트엔드 코드는 CDN에 넣어둘 수가 있다. 누군가 웹페이지에 방문하면 HTML 컨텐츠는 CDN에서 제공되고 페이지의 내용은 인증 헤더의 토큰을 사용하는 API 서비스에 의해 생성될 것이다.</p>
</li>
<li>
<p>No Cookie-Session (or NO CSRF). CSRF(사이트간 요청 위조)는 세션 유지에 일반적으로 사용되는 쿠키 정보만 만족하면 요청이 수행되는 취약점을 이용한 공격이다. 예를 들어, 이미 사이트에 로그인하여 쿠키를 들고 있는 사용자가 공격자가 유도한 링크(회원 탈퇴 링크)에 노출되면 회원 탈퇴 요청이 서버로 전달되고 탈퇴가 되어버린다. 이미 쿠키가 사용자 정보를 포함하고 있기 때문에 회원 탈퇴 요청 URL로 접속만하면 웹서버는 요청을 신뢰하고 명령을 수행하는 것이다. 이 문제를 해결하기 위해 탈퇴 시 비밀번호를 한번 더 요구하거나 요청에 토큰과 같은 credential을 포함하는 방법을 사용한다. 토큰 기반 인증에서 토큰은 인증 헤더 내에 포함되기 때문에 CSRF를 방지할 수 있다.</p>
</li>
<li>
<p>지속적인 토큰 저장. 어플리케이션 내에서 세션 읽기, 쓰기, 삭제 동작이 발생하면 최소 1회 OS의 temp 폴더에 file 관련 동작이 발생한다. 여러개의 서버를 갖고 있고 한 세션이 첫번째 서버에 생성되었다고 해보자. 이 상태에서 새로운 요청이 발생하고 그 요청이 다른 서버에 전달되면, 해당 서버에는 세션 정보가 없을 것이기 때문에 &quot;unauthrized&quot; 응답을 받을 것이다. 물론 sticky 세션(처음에 접속했던 서버와 같은 서버에 계속 연결시키는 것)을 사용하여 이 문제를 해결할 수 있다. 하지만 토큰 기반 인증에서는 이 문제 자연스럽게 해결된다. 요청 토큰은 모든 요청, 모든 서버가 가로채기 때문이다.</p>
</li>
</ul>
<p>이것들이 토큰 기반 인증의 가장 일반적인 장점이다. 이로써 이론적인 설명을 마치고 연습 예제를 보도록 하자.</p>
<hr>
<h3 id="2">토큰기반 인증을 시연하기위해 아래 2개의 어플리케이션 을 살펴보자.</h3>
<ol>
<li>token-based-auth-backend</li>
<li>token-based-auth-frontend</li>
</ol>
<p>백엔드 프로젝트 예제에서는 서비스가 실행되고 서비스의 결과가 JSON 포맷으로 반환될 것이다. 서비스에서는 결코 view가 리턴되지 않는다. 프론트엔드 예제는 HTML을 위한 AngularJS 프로젝트이며, 프론트엔드 앱은 백엔드 서비스로 요청을 보내는 AngularJS 서비스에 의해 작성될 것이다.</p>
<h4 id="tokenbasedauthbackend">token-based-auth-backend</h4>
<pre><code>// mongoose를 사용하기 위해 해당 모듈을 import
var mongoose    = require('mongoose'); 

// 스키마 정의

./models/Users.js
// email, password, token 필드를 가지며 각각의 필드는 string 타입이다.
var Schema       = mongoose.Schema;
var UserSchema   = new Schema({
    email: String,
    password: String,
    token: String
});

// 스키마를 이용해서 모델을 정의
// 'User' : mongodb에 저장될 collection이름(테이블명)
// UserSchema : 모델을 정의하는데 사용할 스키마
module.exports = mongoose.model('User', UserSchema);
</code></pre>
<p>./server.js</p>
<pre><code>// 필요한 모듈 import
var express    = require(&quot;express&quot;);
var morgan       = require(&quot;morgan&quot;);
var bodyParser = require(&quot;body-parser&quot;);
var jwt             = require(&quot;jsonwebtoken&quot;);
var mongoose  = require(&quot;mongoose&quot;);
var app           = express();

var port = process.env.PORT || 3001;
var User     = require('./models/User');

// DB 연결
mongoose.connect(process.env.MONGO_URL); //mongodb://localhost/dbname

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());
app.use(morgan(&quot;dev&quot;)); // 모든 요청을 console에 기록
app.use(methodOverride()); // DELETE, PUT method 사용
app.use(function(req, res, next) {
    //모든 도메인의 요청을 허용하지 않으면 웹브라우저에서 CORS 에러를 발생시킨다.
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,content-type, Authorization');
    next();
});


// 로그인
// 다른 endpoint에 접근할 수 있는 토큰을 얻는다.
app.post('/authenticate', function(req, res) {
    User.findOne({email: req.body.email, password: req.body.password}, function(err, user) {
        if (err) {
            res.json({
                type: false,
                data: &quot;Error occured: &quot; + err
            });
        } else {
            if (user) {
               res.json({
                    type: true,
                    data: user,
                    token: user.token
                }); 
            } else {
                res.json({
                    type: false,
                    data: &quot;Incorrect email/password&quot;
                });    
            }
        }
    });
});

// 신규가입
// 계정과 토큰을 생성한다.
app.post('/signin', function(req, res) {
    User.findOne({email: req.body.email, password: req.body.password}, function(err, user) {
        if (err) {
            res.json({
                type: false,
                data: &quot;Error occured: &quot; + err
            });
        } else {
            if (user) {
                res.json({
                    type: false,
                    data: &quot;User already exists!&quot;
                });
            } else {
                var userModel = new User();
                userModel.email = req.body.email;
                userModel.password = req.body.password;
                userModel.save(function(err, user) { // DB 저장 완료되면 콜백 함수 호출
                    user.token = jwt.sign(user, process.env.JWT_SECRET); // user 정보로부터 토큰 생성
                    user.save(function(err, user1) {
                        res.json({
                            type: true,
                            data: user1,
                            token: user1.token
                        });
                    });
                })
            }
        }
    });
});

// 나의 정보
// 토큰 검사 후 계정 정보 반환
// 토큰 추출하기 위해 ensureAuthorized 먼저 실행
app.get('/me', ensureAuthorized, function(req, res) {
    User.findOne({token: req.token}, function(err, user) {
        if (err) {
            res.json({
                type: false,
                data: &quot;Error occured: &quot; + err
            });
        } else {
            res.json({
                type: true,
                data: user
            });
        }
    });
});

// 요청 헤더 내의 authorization 헤더에서 토큰 추출
// 토큰이 존재하면, 토큰을 req.token에 할당
function ensureAuthorized(req, res, next) {
    var bearerToken;
    var bearerHeader = req.headers[&quot;authorization&quot;];
    if (typeof bearerHeader !== 'undefined') {
        var bearer = bearerHeader.split(&quot; &quot;);
        bearerToken = bearer[1];
        req.token = bearerToken;
        next(); // 다음 콜백함수 진행
    } else {
        res.send(403);
    }
}

process.on('uncaughtException', function(err) {
    console.log(err);
});

// Start Server
app.listen(port, function () {
    console.log( &quot;Express server listening on port &quot; + port);
});
</code></pre>
<h3 id="">결론</h3>
<p>클라이언트 독립적인 서비스를 구현할 때 토큰 기반 인증/인가 방식은 인증 시스템을 구축하는데 많은 도움을 준다. 이 기술을 사용함으로써 서비스(또는 API) 개발에만 집중할 수 있다. 인증/인가 부분은 토큰 기반 인증 시스템에 의해 서비스의 앞단에서 하나의 '레이어'로써 핸들링될 것이다. 웹 브라우저, 안드로이드, iOS, 데스크탑 클라이언트 등 어떤 클라이언트를 통해서도 서비스에 접근하고 서비스를 사용할 수 있다.</p>
<p>이 링크에서 튜토리얼을 확인할 수 있다.<br>
<a href="http://token-based-auth.herokuapp.com/">working demo</a>.</p>
<h3 id="">개선사항</h3>
<ol>
<li>비밀번호가 해쉬 암호화되어 저장되어야하고 로그인시 해쉬값을 전달받아 비교해야 한다.</li>
</ol>
<pre><code>// bcrypt 사용
UserScheme.pre('save', function (callback) { 
  // salt와 암호화된 비밀번호 생성
  var user = this;
  if (!user.isModified('password')) return next();
 
  bcrypt.genSalt(SALT_WORK_FACTOR, function(err, salt) {
    if (err) return next(err);
 
    bcrypt.hash(user.password, salt, function(err, hash) {
        if (err) return next(err);
        user.password = hash;
        next();
    });
  });
}

// 비밀번호 검증
UserSchema.methods.verifyPassword = function(password, cb) {    
    bcrypt.compare(password, this.password, function(err, isMatch) {
        if (err) return cb(err);
        cb(isMatch);
    });
};

// 로그인
app.post('/authenticate', function(req, res) {
...
      user.comparePassword(password, function(isMatch) {
          if (!isMatch) {
              console.log(&quot;Attempt failed to login with &quot; + user.username);
              return res.send(401);
          }
          ...
      });
...
}
</code></pre>
<ol start="2">
<li>토큰의 유효성 검사가 수행되어야 하며, 토큰이 만료되어야 한다.</li>
</ol>
<pre><code>function ensureAuthorized(req, res, next) {
    ...
    jwt.verify(bearerToken, process.env.JWT_SECRET)
    ...
}
</code></pre>
<p>위의 개선사항이 반영된 소스 :</p>
<ul>
<li><a href="http://thejackalofjavascript.com/architecting-a-restful-node-js-app/">http://thejackalofjavascript.com/architecting-a-restful-node-js-app/</a></li>
<li><a href="http://www.kdelemme.com/2014/03/09/authentication-with-angularjs-and-a-node-js-rest-api/">http://www.kdelemme.com/2014/03/09/authentication-with-angularjs-and-a-node-js-rest-api/</a></li>
</ul>
<p>참고자료 :</p>
<ol>
<li><a href="http://bcho.tistory.com/999">REST JWT(JSON Web Token)소개</a></li>
<li><a href="http://bcho.tistory.com/1005">MSA 아키텍쳐 구현을 위한 API 게이트웨이의 이해 (API GATEWAY)</a></li>
<li><a href="https://velopert.com/2350">토큰기반인증소개</a></li>
<li><a href="https://www.toptal.com/web/cookie-free-authentication-with-json-web-tokens-an-example-in-laravel-and-angularjs">Laravel&amp;Angularjs Login</a></li>
</ol>
]]></content:encoded></item><item><title><![CDATA[[LeetCode] #16 - 3Sum Closest]]></title><description><![CDATA[<p>이번 문제는 3Sum문제와 유사하지만 3개정수의 합이 입력받은 target에 가까운 수의 정수를 리턴하는 문제이다.</p>
<p>난의도 : ★★★☆☆</p>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each</p>]]></description><link>https://blog.chulgil.me/leetcode-016/</link><guid isPermaLink="false">5c548f2c8db38e00010451ed</guid><category><![CDATA[kr]]></category><category><![CDATA[CODE]]></category><category><![CDATA[ALGORITHM]]></category><category><![CDATA[LeetCode]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Fri, 01 Feb 2019 19:40:27 GMT</pubDate><content:encoded><![CDATA[<p>이번 문제는 3Sum문제와 유사하지만 3개정수의 합이 입력받은 target에 가까운 수의 정수를 리턴하는 문제이다.</p>
<p>난의도 : ★★★☆☆</p>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><pre><code>Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre>
<h3 id="">먼저 의사코드를 작성하면 아래와 같다.</h3>
<pre><code>1. 입력받은 수들을 오름차순 정렬한다.
2. 근사값에 정수의 최대값을 할당한다.
     최대값을 할당하면 처음 합과 비교할때 무조건 크기때문에 
      조건문에서 초기값을 설정할 수 있다.
3. 입력받은 리스트에서 -2만큼 순회한다.
    4. 첫번째 포인트를 0으로 초기화
    5. 두번째 포인트를 세번째포인트 - 1으로 초기화
    6. 세번째 포인트를 2로 초기화
    7. 첫번째 포인트보다 두번째 포인트가 클동안 순회한다.
        8. 합계 = 리스트[첫] + 리스트[두] + 리스트[세]
        9. 찾는값 타겟이 합계와 같으면 타겟을 리턴하고 종료한다.
        10. 현재 합계가 타겟에 가장 가까운 값인경우 근사값에 절대값(합계-타겟)를  
            설정하고 결과값에 합계를 설정한다.
        11. 타겟이 합계보다 크면 첫번째 포인트를 증가시킨다.
        12. 아니면 두번째 포인트를 감소시킨다.
13. 결과값을 리턴한다. 
</code></pre>
<hr><h3 id="">코드로 구현하기 (파이썬)</h3>
<pre><code class="language-py">class Solution:
    def threeSumClosest(self, nums, target):
        nums.sort()
        closest = float('inf')
        for p in range(2, len(nums)):
            l = 0
            r = p - 1
            while l &lt; r:
                sum = nums[l] + nums[r] + nums[p]
                if target == sum: return target
                if abs(target-sum) &lt; closest:
                    closest = abs(target-sum)
                    res = sum
                if target &gt; sum: l += 1
                else : r -= 1
     return res
</code></pre>
<ul>
<li>파이썬에서는 정수의 MAX값이 존재하지 않지만 공식적으로 최대값을 구하는 방법은<br>
라이러리를 이용한 <code>sys.maxint - 1</code>이다. <a href="https://docs.python.org/2/library/stdtypes.html#numeric-types-int-float-long-complex">이 링크</a>에서 확인할 수 있다.<br>
하지만 라이브러리 이용은 가급적 피하고 싶어서 무한수<code>flost('inf')</code>를 이용하였다.</li>
</ul>
<p>실행해보면 테스트케이스 125를 통과한 결과 124 ms가 나오는 것을 확인 할 수 있다.<br>
시간복잡도는 O(n^2) 이다.</p>
]]></content:encoded></item><item><title><![CDATA[[LeetCode] #015 Three Sum - Improve speed]]></title><description><![CDATA[<p>이번 포스트에서는 <a href="https://blog.chulgil.me/leetcode-015/">지난번에 구현한 3Sum</a>의 속도를 개선시킨 알고리즘을 설명한다.</p>
<p>알고리즘 설명은 <a href="https://blog.chulgil.me/leetcode-015/">이 링크</a>에서 확인할 수 있다.</p>
<h3 id="">먼저 의사코드를 작성하면 아래와 같다.</h3>
<pre><code>입력받은 요소 = [-4, -3, -2, 1, 0, 1, 2, 2, 3]

0. 리턴받을 리스트를 생성한다.
1. 입력받은 요소를 오름차순정렬한다.
2. 입력받은 요소들을 검색사전으로 만들기위해 해쉬맵을 생성한다.
3.</code></pre>]]></description><link>https://blog.chulgil.me/leetcode-015-2/</link><guid isPermaLink="false">5c4f81c98db38e0001045158</guid><category><![CDATA[kr]]></category><category><![CDATA[CODE]]></category><category><![CDATA[ALGORITHM]]></category><category><![CDATA[LeetCode]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Tue, 29 Jan 2019 19:01:57 GMT</pubDate><content:encoded><![CDATA[<p>이번 포스트에서는 <a href="https://blog.chulgil.me/leetcode-015/">지난번에 구현한 3Sum</a>의 속도를 개선시킨 알고리즘을 설명한다.</p>
<p>알고리즘 설명은 <a href="https://blog.chulgil.me/leetcode-015/">이 링크</a>에서 확인할 수 있다.</p>
<h3 id="">먼저 의사코드를 작성하면 아래와 같다.</h3>
<pre><code>입력받은 요소 = [-4, -3, -2, 1, 0, 1, 2, 2, 3]

0. 리턴받을 리스트를 생성한다.
1. 입력받은 요소를 오름차순정렬한다.
2. 입력받은 요소들을 검색사전으로 만들기위해 해쉬맵을 생성한다.
3. 해쉬맵의 키에 입력받은 요소들을 담고 값에는 중복되는 값을 카운트한다.
   ex [-2,-1,0,0]:) hashmap[-2] = 1, hashmap[-1] = 1, hashmap[0] = 2
3. 검색사전의 키값중 0의 값이 2개 이상이라면 리스트에 [0,0,0]을 추가한다.
4. 검색사전으로 음수 집합 리스트를 생성한다.
5. 검색사전으로 양수 집합 리스트를 생성한다.
6. 음수 집합 리스트를 순환한다.
    7. 양수 집합 리스트를 순환한다.
        8.  음수요소와 양수요소를 더한 값을 합계에 설정하고 부호를 반전시킨다.
        9.  검색사전에 합계가 존재하지 않으면 루프를 건너뛴다.
        10. 다음 경우에 수에 해당하는 리스트를 추가한다.
            [음의요소, 합계, 양의요소] 합계가 0인 경우
            [합계, 음의요소, 양의요소] 합계가 음의요소보다 작을경우
            [음의요소, 양의요소, 합계] 합계가 양의요소보다 클경우
            [음의요소, 음의요소, 양의요소] 합계가 음의요소와 같고 요소가 1개이상인경우
            [양의요소, 양의요소, 음의요소] 합계가 양의요소와 같고 요소가 1개 이상인경우
11. 리스트를 반환한다.
</code></pre>
<h3 id="">코드로 구현하기 (파이썬)</h3>
<pre><code>class Solution:
    def threeSum(self, nums):
        res = []
        nums.sort()
        lookup = dict()
        for num in nums:
            if num in lookup: lookup[num] += 1
            else: lookup[num] = 1
    
        if 0 in lookup and lookup[0] &gt; 2: res.append([0,0,0])
        neg = [n for n in lookup if n &lt; 0]
        pos = [n for n in lookup if n &gt; 0]
        for n in neg:
            for p in pos:
                sum = -p - n
                if sum not in lookup: continue
                if sum == 0: res.append([n,sum,p])
                elif sum &lt; n: res.append([sum,n,p])
                elif sum &gt; p: res.append([n,p,sum])
                elif sum == n and lookup[sum] &gt; 1: res.append([n,n,p])
                elif sum == p and lookup[sum] &gt; 1: res.append([n,p,p])
        return res
</code></pre>
<p>이 알고리즘의 경우또한 O(n^2)로 시간복잡도가 전과 같지만 이미 계산된 결과값을 해시테이블에서 찾기때문에 속도가 빠르다. 실행시켜보면 313개의 테스트를 통과하고 런타임시간이 320 ms로 전보다 약 5배정도 빨라진 것을 확인 할 수 있다.</p>
<h3 id="3sum-closet-"><a href="https://blog.chulgil.me/leetcode-016/">3Sum Closet 문제 보러가기</a><br></h3>]]></content:encoded></item><item><title><![CDATA[[LeetCode] #015 Three Sum]]></title><description><![CDATA[<p></p><p>지난 포스트에서 Two Sum을 구현했었는데 이번 Three Sum문제에서 활용할 수 있다.<br>
먼저 문제는 아래와 같다.</p>
<p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:</p>]]></description><link>https://blog.chulgil.me/leetcode-015/</link><guid isPermaLink="false">5c4f57468db38e00010450d2</guid><category><![CDATA[kr]]></category><category><![CDATA[CODE]]></category><category><![CDATA[ALGORITHM]]></category><category><![CDATA[LeetCode]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Mon, 28 Jan 2019 22:19:25 GMT</pubDate><content:encoded><![CDATA[<p></p><p>지난 포스트에서 Two Sum을 구현했었는데 이번 Three Sum문제에서 활용할 수 있다.<br>
먼저 문제는 아래와 같다.</p>
<p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:</p>
<p>The solution set must not contain duplicate triplets.</p>
<p>Example:</p>
<pre><code>Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre>
<p>위 예제처럼 배열 3개 요소를 더하여 0이 되는 요소들을 중복없이 반환하는 문제다.</p>
<h3 id="">이것을 의사코드로 작성해보면 다음과 같다.</h3>
<pre><code>0. Two Sum함수 작성
1. 배열요소를 오름차순 정렬한다.
2. 배열요소를 담을 해쉬셋를 생성
3. 입력받은 요소들이 2보다 클 동안 
    4. 배열요소에서 첫번째 요소를 추출한다.
    5. TwoSum(배열요소)함수에서 결과값을 받아서 리스트에 담는다.
    6. 리스트의 요소를 순회하면서
        7. 첫번째 요소가 리스트에 존재하면 해쉬셋에 추가한다.
8. 해쉬셋을 리스트로 반환한다.
</code></pre>
<hr>
<h2 id="">코드로 구현하기 (파이썬)</h2>
<h3 id="0twosum">0. Two Sum 함수 작성</h3>
<p>먼저 지난 시간에 작성했던 Two Sum함수를 작성하면 아래와 같다.<br>
원래는 처음 찾은 인덱스만 반환했었는데 일치하는 모든 데이터셋을 반환하도록 변경했다.</p>
<pre><code class="language-py">    def twoSum(self, nums, target):
        lookup = {}
        hashset = set()
        for index, item in enumerate(nums):
            if item in lookup : hashset.add((nums[lookup[item]], nums[index]))
            else : lookup[target - item] = index
        return hashset
</code></pre>
<h3 id="18">1-8. 구현하기</h3>
<pre><code class="language-py">    def threeSum(self, nums):
        nums.sort()
        res = set()
        while len(nums) &gt; 2 :
            key = nums.pop(0)
            tmp = self.twoSum(nums, -key)
            for item in tmp:
                res.add((key, item[0], item[1]))
        return [list(item) for item in res]
</code></pre>
<p>시간복잡도는: O(n^2)인 알고리즘이며 효율성보다는 심플한 알고리즘 설계를 목표로 했다.<br>
실행시켜보면 원하는 결과 값을 확인 할 수 있는데 LeetCode에서 313개의 코드테스트 결과 1.6초가 나왔다.<br>
다음번 포스트에서는 같은 문제를 효율성을 높인 다른 알고리즘으로 풀어 볼 것이다.</p>
<pre><code>solution = Solution()
print(solution.threeSum([-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]))

[[-4, -2, 6], [-2, 0, 2], [-4, 1, 3], [-2, -2, 4], [-4, 2, 2], [-4, 0, 4]]

Runtime: 1604 ms, faster than 32.52% of Python3 online submissions for 3Sum.
</code></pre>
<h3 id="three-sum-"><a href="https://blog.chulgil.me/leetcode-015-2/">Three Sum 스피드개선 보러가기</a></h3>]]></content:encoded></item><item><title><![CDATA[[LeetCode] #001 Two Sum]]></title><description><![CDATA[<p>LeetCode 에서 Three Sum 문제를 해결하기 위해서는 Two Sum을 구현할 줄 알아야하므로<br>
Two Sum을 구현해보려한다.</p>
<p><a href="https://leetcode.com/problems/two-sum/solution/">https://leetcode.com/problems/two-sum/solution/</a></p>
<blockquote>
<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>
You may assume that each input would have exactly</p></blockquote>]]></description><link>https://blog.chulgil.me/leetcode-001/</link><guid isPermaLink="false">5c49fab38db38e0001044fae</guid><category><![CDATA[kr]]></category><category><![CDATA[CODE]]></category><category><![CDATA[ALGORITHM]]></category><category><![CDATA[LeetCode]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Fri, 25 Jan 2019 21:12:00 GMT</pubDate><content:encoded><![CDATA[<p>LeetCode 에서 Three Sum 문제를 해결하기 위해서는 Two Sum을 구현할 줄 알아야하므로<br>
Two Sum을 구현해보려한다.</p>
<p><a href="https://leetcode.com/problems/two-sum/solution/">https://leetcode.com/problems/two-sum/solution/</a></p>
<blockquote>
<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>
You may assume that each input would have exactly one solution, and you may not use the same element twice</p>
</blockquote>
<p>Example :</p>
<pre><code>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>
<p>먼저 주어진 정수배열에서 두 값의 합이 찾고자 하는 값일 경우 두 인덱스들의 요소를 리턴하면 되는데<br>
동일한 요소는 한번만 사용해야한다.</p>
<p>먼저 단순하게 생각해 보면 각 요소를 n번 반복하면서 (target값 - x) 과 같다면 요소를 리턴하는<br>
코드를 작성해 볼 수 있다.</p>
<pre><code class="language-py">def twoSum(self, nums, target):
    for x in range(len(nums)):
        for y in range(len(nums)):
            if nums[y] == target - nums[x]:
                return [x, y]
    return []
</code></pre>
<p>이때 시간복잡도는 <code>O(n^2)</code> 이므로 효율이 떨어지는 알고리즘이라 할 수있다.</p>
<p>배열을 처음부터 끝까지 다 찾아야하는 이 알고리즘을 개선하기 위해서는<br>
O(1)공간과 O(n)시간을 교환하는 알고리즘을 사용할 수 있다.<br>
즉 중복이 배제된 요소가 배열의 키로 들어가 있다면 시간복잡도 : O(n)으로 훨씬더 빠르게 찾을 수 있다.<br>
이런 알고리즘에 최적화 된 것은 바로  해시테이블이다.</p>
<p>먼저 코딩할 알고리즘을 풀어보면 아래와 같다.</p>
<pre><code>1. 먼저 해시테이블을 생성하고
2. 검색테이블을 순회하면서
3. 만약 해시테이블에 검색키가 존재한다면 배열[x,y]를 리턴하고
4. 그렇지 않으면 해시테이블의 키에 [target-배열의 요소값]로 하고 값을 요소의 키값으로 넣는다.
</code></pre>
<p>이제 파이썬으로 구현해보자.</p>
<pre><code class="language-py">class Solution:
    def twoSum(self, nums, target):
        hashmap = {}
        for index, item in enumerate(nums):
            if item in hashmap:
                return [hashmap[item], index]
            else:
                hashmap[target - item] = index
        return []
</code></pre>
<p>이제 프로그램을 실행시켜 보면 시간복잡도 O(n)으로 개선시킨 결과값을 볼 수 있다.</p>
<pre><code>solution = Solution()
print(solution.twoSum([2, 5, 7, 15], 9))
[0, 2]

Process finished with exit code 0
</code></pre>
<p></p><h3 id="3sum"><a href="https://blog.chulgil.me/leetcode-015">3Sum 문제 보러가기</a></h3>
]]></content:encoded></item><item><title><![CDATA[[LeetCode] #168 Excel Sheet Column Title]]></title><description><![CDATA[<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<pre><code>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB 
...
</code></pre>
<p>Example :</p>
<pre><code>Input: 1
Output: &quot;A&quot;
Input: 28</code></pre>]]></description><link>https://blog.chulgil.me/leetcode-168/</link><guid isPermaLink="false">5c4b35538db38e0001044fd1</guid><category><![CDATA[kr]]></category><category><![CDATA[CODE]]></category><category><![CDATA[ALGORITHM]]></category><category><![CDATA[LeetCode]]></category><dc:creator><![CDATA[Chulgil.Lee]]></dc:creator><pubDate>Fri, 25 Jan 2019 19:30:42 GMT</pubDate><content:encoded><![CDATA[<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<pre><code>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB 
...
</code></pre>
<p>Example :</p>
<pre><code>Input: 1
Output: &quot;A&quot;
Input: 28
Output: &quot;AB&quot;
Input: 701
Output: &quot;ZY&quot;
</code></pre>
<hr><h3 id="">분석해보기</h3>
<p>이 문제는 우리가 자주 사용하는 엑셀의 시트컬럼 문자를 숫자로 만드는 것인데 먼저 컬럼문자가 만들어지는  패턴을 분석해보면 아래와 같다.</p>
<p>일단 알파벳의 수는 26개 이며 Z(26)를 넘은 숫자가 오면 다시 A가 된다. 즉 27이면 ZA가 될것이다.</p>
<pre><code>ABCDEFGHIJKLMNOPQRSTUVWXYZ
12345678901234567890123456
</code></pre>
<pre><code>A   1   AA  26+ 1   ...   ZA  26×26+ 1   AAA  1×26²+1×26+ 1
B   2   AB  26+ 2   ...   ZB  26×26+ 2   AAB  1×26²+1×26+ 2
.   .   ..  .....   ...   ..  ........   ...  .............
.   .   ..  .....   ...   ..  ........   ...  .............
Z  26   AZ  26+26   ...   ZZ  26×26+26   AAZ  1×26²+1×26+26
</code></pre>
<p>따라서 Output: &quot;ZY&quot;가 만들어지려면 아래와 같이 만들 수 있다.<br>
ZY = Z x 26¹ + Y<br>
ZY = 26 x 26¹ + 25<br>
이번엔 숫자로부터 컬럼문자를 만드려면 반대로 (n % 26) 를 사용하면 된다.<br>
701 / 26 = 26 = Z<br>
701 % 26 = 25 = Y</p>
<p>결국 26이라는 알파벳 바운더리에서 계속 나누어진 값이 0이면 계산을 종료할 수 있다.<br>
<code>IF 26 / 26 == 0</code><br>
하지만 27 / 26 이든 26 / 26 이든 결과값은 항상 1일 것이다.<br>
따라서 (n - 1) / 26으로 계산식을 만들면 결과 값이 0이기 때문에 이런식을 사용한다.</p>
<h3 id="">숫자를 알파벳으로</h3>
<p>컴퓨터는 수로 이루어져있기 때문에 이 수를 이용해서 알파벳을 표현할수 있는 <a href="https://www.ascii-code.com/">ASCII테이블</a>을 만들었다.<br>
대문자 A를 표현하기 위해서는 십진수 65를 사용하는데 파이썬에서는 <code>chr(65)함수</code>를 이용하면 <code>A</code>가 출력된다. 반대로 <code>ord(&quot;A&quot;)함수</code>를 이용하면 <code>65</code>가 출력된다.</p>
<h3 id="">코드로 구현하기 (파이썬)</h3>
<pre><code class="language-py">
class Solution:
    def convertToTitle(self, n):
        str = ''
        while n != 0
            tmp = 'A' + (n-1) % 26
            n = (n-1) // 26
            str = tmp + str
        return str

</code></pre>
<p>시간 복잡도는 : O(N) 공간복잡도는 : O(N)인 알고리즘이며<br>
이제 실행시켜보면 원하는 결과값을 확인 할 수 있다.</p>
<pre><code>solution = Solution()
print(solution.convertToTitle(701))

ZY
Process finished with exit code 0
</code></pre>
<p></p>]]></content:encoded></item></channel></rss>